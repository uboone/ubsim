////////////////////////////////////////////////////////////////////////
// Class:       CRTRawInputDetail
// Module Type: source
// File:        CRTRawInputDetail_source.cc
// Version: V02_00 || added NTP correction and GPS correction || added half top option || second assigmnent depends on full ts0 seconds.
// Generated by David Lorca Galindo / Thomas Mettler
////////////////////////////////////////////////////////////////////////
#include "art/Framework/Core/InputSourceMacros.h"
#include "art/Framework/IO/Sources/Source.h"
#include "art/Framework/IO/Sources/SourceTraits.h"

#include "fhiclcpp/ParameterSet.h"
#include "art/Framework/Core/ProductRegistryHelper.h"
#include "art/Framework/IO/Sources/SourceHelper.h"
#include "art/Framework/Core/FileBlock.h"
#include "art/Framework/Principal/RunPrincipal.h"
#include "art/Framework/Principal/SubRunPrincipal.h"
#include "art/Framework/Principal/EventPrincipal.h"
#include "canvas/Persistency/Provenance/SubRunID.h"
#include "art/Framework/IO/Sources/put_product_in_principal.h"

#include "art/Framework/Services/Optional/TFileService.h"

#include "ubooneobj/CRT/CRTHit.hh"
#include "ubooneobj/CRT/CRTTrack.hh"
#include "uboone/CRT/CRTAuxFunctions.hh"

#include <fstream>
#include <iostream>
#include <vector>
#include <algorithm>
#include <string>
#include <memory>
#include <initializer_list>

// ROOT includes                                                                                                                                                
#include "TTree.h"
#include "TFile.h"
#include <stdint.h>

#include "ubooneobj/CRT/CRTHit.hh"
#include "ubooneobj/CRT/CRTTrack.hh"
//#include "uboone/CRT/pair_builder_debug_6msts1.h"
#include "uboone/CRT/CRTAuxFunctions.hh"

#include "TH1F.h"
#include "TH2F.h"
#include "TH3S.h"
#include "TProfile.h"
#include "TF1.h"
#include "TDatime.h"
#include <iostream>
#include <stdio.h>
#include <sstream>
#include <vector>
#include <map>
#include <utility>
#include <memory>
#include <iomanip> // needed to use manipulators with parameters (precision, width)

#include <exception>

#define MAX_TIME_PREBEAM 2000000 //ns before beam ts1
#define MAX_TIME_PASTBEAM 4000000 //ns after beam ts1
#define EVLEN 80        // event length of a raw event (80 for uBooNE)
#define EVSPERFEB 1024   // max events per feb per poll to buffer
#define MAXFEBNR 200
#define MSOVERLAP 2000000// ns of previous second (>= MAX_TIME_PREBEAM)
#define MAX_TIME_DIFFERENCE 400   //Set the maximal timedifference between hits

//define numbers to controll bufferstatus
#define PROBUF_READY_TO_FILL  0
#define PROBUF_FILLING        1
#define PROBUF_READY_TO_SCALE 2
#define PROBUF_SHIFT_SCALE    3
#define SCANBUF_READY_TO_FILL 0
#define SCANBUF_SCANNING      1

#define FILTER_PAIR_MODE 3
#define TS1_CORR 11

#define STRIPW 10.8

namespace crt {
  // Forward declaration of detail class.
  class CRTRawInputDetail;
  struct EVENT_t;
  struct EVENT_t_send;
  struct EVENT_tpro;
  struct EOP_EVENT_t;
  struct SCAN_ORDER;
  //struct TS0_CORRECTION;
}
struct crt::EVENT_t{
		uint16_t mac5;
		uint16_t flags;
    uint16_t lostcpu;
    uint16_t lostfpga;
		uint32_t ts0;
		uint32_t ts1;
		uint16_t adc[32];
};
struct crt::EVENT_t_send {
		uint16_t mac5;
		uint16_t flags;
    uint16_t lostcpu;
    uint16_t lostfpga;
		uint32_t ts0;
    uint32_t ts0_corr;
		uint32_t ts1;
    uint32_t sec;
    uint32_t sec_corr;
		uint16_t adc[32];
    uint16_t recover;
    uint32_t nrtrigger;
    uint32_t nrtrigger_11;
};
struct crt::EVENT_tpro {
		uint16_t mac5;
		uint16_t flags;
    uint16_t lostcpu;
		uint16_t lostfpga;
		uint32_t ts0;
		uint32_t ts1;
		uint16_t adc[32];
		uint32_t ts0_scaled;
    uint32_t ts0_corr;
    uint32_t sec_corr;
    uint32_t ts1_scaled;
		uint32_t sec;
    uint32_t ts0_ref;
    uint32_t ms;
    uint16_t recover;
    uint32_t nrtrigger;
    uint32_t nrtrigger_11;
};
struct crt::EOP_EVENT_t {
		uint16_t mac5; // ==0xFFFF
		uint16_t flags; // ==0xFFFF
		uint16_t lostcpu;
		uint16_t lostfpga;
		uint32_t ts0; // ==MAGICWORD32
		uint32_t ts1; // ==MAGICWORD32
    int nevsinpoll; 
		uint32_t start_s;
		uint32_t d1;
		uint16_t start_ms;
		uint16_t dd2;
		uint32_t d2;
		uint32_t end_s;
		uint32_t d3;
		uint16_t end_ms;
};  // end-of-poll special event
struct crt::SCAN_ORDER{
  uint32_t sec;
  int ref_nr;
  uint32_t ts0_ref;
  int flags;
};
/*struct crt::TS0_CORRECTION{
  uint32_t sec;
  double offset;
  double scale;
};*/

class crt::CRTRawInputDetail {
  
public:
  CRTRawInputDetail(fhicl::ParameterSet const &pset,
		    art::ProductRegistryHelper &helper,
		    art::SourceHelper const &src_hlpr);
  
  void readFile(std::string const & filename, art::FileBlock*& fb);
  
  bool readNext(art::RunPrincipal const* const inR,
                art::SubRunPrincipal const* const inSR,
                art::RunPrincipal*& outR,
                art::SubRunPrincipal*& outSR,
                art::EventPrincipal*& outE);
  void closeCurrentFile();
  
private:
  
  art::SourceHelper  const& fSourceHelper;
  std::string        fModuleLabel;
  std::string        fInstanceLabel;
  std::ifstream      fInputStreamList;

  size_t             fEventNumber;
  size_t             fPrevRunNumber;
  size_t             fPrevSubRunNumber;

  std::vector<std::ifstream>                  fInputStreams;
  std::vector<art::Timestamp>                 fInputStreamLastPullTime;
  
  //pair_builder stuff here////////////////////////////////////////////////////////////////////
  //pair functions///////////////////////////////////////
  void receive_data(); // receive data from zmq socket
  void shift_scale(int mac, int ref_nr, int ts0_ref); //scale the timestamps and copy them for processing
  void scale_buffer();  // scale the timestams
  void scan_buffer_filter(int mac);  // scan/process all hits of the FEBs and searches for coincidences
  void filter_buffer(int mac);
  void scan_filter_buffer(int mac);
  unsigned int my_abs(unsigned int, unsigned int);  //define absolutevalue for uint
  //hit functions://////////////////////////////////////

  void make2DHit();
  void check_storing();
  
  //correction functions NTP / GPS
  //void Init_TS0_corr(std::string fileTop);
  double NTP_deviation(std::string fileTop);
  //void Init_mspoll_delay(void);
  //void Init_HalfTop(std::string filename, int mac_buffer[3][100]);
  ////////////////////////////////////////////////////
  
  //pair_builder variables////////////////////////////
  int ready_to_fill, ready_to_scan; //controll numbers to make sure buffers are ready for r/w.
  FILE *data1;
  FILE *data2;
  FILE *data3;
  FILE *data4;
  int read_events1, read_events2, read_events3 ,read_events4;
  
  unsigned long size_ev, tot_events;  // saves total numbers of raw CRT events for printing
  crt::SCAN_ORDER order_buffer[MAXFEBNR+1]; //to scan the events with the lowest second number
  //beamfilter variables////////////
  int last2_ms[MAXFEBNR+1]; // index of event with ts0 > 2*MSOVERLAP in buffer
  int last1_ms[MAXFEBNR+1]; // index of event with ts0 > 1*MSOVERLAP in buffer
  int number_ms[MAXFEBNR+1]; // # of events with ts0 > 1*MSOVERLAP
  //beamfilter variables////////////
  int ts1ref_buffer[100][100];
  int ts1ref_counter[100];
  uint32_t ts1ref_second[100];
  uint32_t previous_sec_mac[MAXFEBNR+1];
  //uint32_t previous_sec_mac2[MAXFEBNR+1];
  //////////////////////////////////
  int ts0ref_counter[MAXFEBNR+1];
  int ts1_ref_counter[MAXFEBNR+1]; // nrwm2[MAXFEBNR+1];
  int run_mode_; //choose the mode (filtering, pairfinding etz...)
  int verbose_;
  int event_counter;
  int fOffset_;
  int NrFiles_;
  int save_event;
  int Split_;
  int WhichHalf_;
  int TopPart_;
  int GPSCorrection_; // =0 correction from matched triggers, =1 correction with CRT NTP deviation
  //pair_builder ends stuff here////////////////////////////////////////////////////////////////////

  std::vector<crt::CRTHit> allCRTHits;
  std::string fSourceFile_;
  std::string  SiPMpositions_;
  std::string  FEBDelays_;
  std::string  CRTGains_;
  std::string  CRTPedestals_;
  std::string  PartTop_;
  std::string  FEB_MS_delay_;
  std::string  CRT_GPS_correction_;
  
	int mac_part_top[3][100];
  
  std::map <int, std::vector<double> > sensor_pos; //key = FEB*100+ch
  std::map <int, double > FEBDel; //key = FEB;
  std::map<int, std::pair<double,double> > SiPMgain; //key = FEB*100+ch
  std::map<int, std::pair<double,double> > SiPMpedestal; //key = FEB*100+ch
  
  //pair_builder buffers ///////////////////////////////////////////////////////////////////////////
  // ev counters////////////////////
  int ev_counter_mac[MAXFEBNR+1];   //Number of events per module (mac) in the processing buffer
  int ev_counter_scan[MAXFEBNR+1];  //Number of events per module (mac) in the scanning buffer
  int ev_counter_filter_scan[MAXFEBNR+1];  //Number of events per module (mac) in the scanning buffer
  int ev_counter_filter[MAXFEBNR+1];
  //////////////////////////////////
  //uint32_t act_time[2][MAXFEBNR+1];    //number to read out the second and ms out of received special event [0]:sec, [1]:ms [][mac]:module [][MAXFEBNR]:time last poll
  //uint32_t previous_sec;// previous_ms;
  //uint32_t previous2_sec;
  int event_time_diff[MAXFEBNR+1];
  int event_time_diff_old[MAXFEBNR+1];
  uint32_t event_ts0;
  uint32_t event_ts1;
  // ev buffers//////////////////////
  crt::EVENT_t evbuf[MAXFEBNR*EVSPERFEB+1];    //buffer to receive events (same structure as the receiving events)
  crt::EVENT_tpro evbuf_pro[MAXFEBNR+1][4*EVSPERFEB+1];  //buffer for processing (add the second, millisecond from sepcial events)
  crt::EVENT_tpro evbuf_scan[MAXFEBNR+1][4*EVSPERFEB+1]; //buffer for scanning for coincidences (same structure as the buffer for processing)
  crt::EVENT_tpro evbuf_filter[MAXFEBNR+1][4*EVSPERFEB+1];
  crt::EVENT_tpro evbuf_filter_scan[MAXFEBNR+1][4*EVSPERFEB+1];
  //crt::EVENT_t_send beam_ev[10][4*EVSPERFEB+1];    //buffer to send out the coincidences (structure idealy same as the received events)
  //crt::EVENT_t ts0_ref_event[2];
  //crt::EVENT_t_send ts0_ref_event_buffer[MAXFEBNR+1][2];
  crt::EVENT_t_send coincidence[MAXFEBNR+1];    //buffer to send out the coincidences (structure idealy same as the received events)
  crt::EOP_EVENT_t refevent;
  std::vector<crt::CRTHit>  allmyCRTHits;
  int total_hits=0;
  int EndOfFile;
  //variable for GPS/NTP correction
  crt::TS0_CORRECTION correctionpoints[50];
  double scale_NTP=0;
  uint32_t start_NTP=0;
  uint32_t end_NTP=0;
  double Ms_poll[200];
  uint32_t previous_sec, previous_ms_start, previous_ms_end,previous_s_end,previous_s_start;
  ///////////////////////////////////////////////////////////////////////////////////////////////

  //Quality Plot and Tree entries: /////////////////////////////////////////////////////////////////////////////////
  art::ServiceHandle<art::TFileService> tfs;
  //quallity plots///////////////////////////
  TH2F* HitDistBot;
  TH2F* HitDistFT;
  TH2F* HitDistPipe;
  TH2F* HitDistTop;

  TH1F* hxtot;
  TH1F* hytot;
  TH1F* hztot;

  TH2F* FEBvsFEB;
  TH1F* TimeDiff;
  TH1F* BeamTime;
  
  TH1F* hPES;
  TH1F* hPEStot;
  //tree entries/////////////////////////////
  TTree*       my_tree_;
  int hit_mac_1=0;
  int hit_mac_2=0;
  double xtot=-10000., ytot=-10000., ztot=-10000.;
  double xerr=-10000., yerr=-10000., zerr=-10000.;
  double hit_time_ns = -1e18;
  double hit_time_s = -1e18;
  double hit_time_ms = -1e18;
  double beam_time_ns = -1e18;
  int beam_trigger = -1;
  int pps_trigger=-1;
  int plane = -1;
  double td = -1e19;
  double pestot = -1e19;
  std::map< uint8_t, std::vector<std::pair<int,float> > > pesmap;
  ////////////////////////////////////////////////////////////////////////////////////////////////
};


crt::CRTRawInputDetail::CRTRawInputDetail(fhicl::ParameterSet const & ps,
                                                               art::ProductRegistryHelper & helper,
                                                               art::SourceHelper const & src_hlpr)
  : fSourceHelper(src_hlpr),
    fModuleLabel(ps.get<std::string>("ModuleLabel")),
    fInstanceLabel(ps.get<std::string>("InstanceLabel")),
    fEventNumber(0),
    fPrevRunNumber(0),
    fPrevSubRunNumber(0)
{
  helper.reconstitutes< std::vector<crt::CRTHit>, art::InEvent >(fModuleLabel,fInstanceLabel);
  run_mode_ = ps.get<int>("run_mode");
  NrFiles_ = ps.get<int>("Nr_Files");
  SiPMpositions_= ps.get<std::string>("CRTpositions_file");
  FEBDelays_= ps.get<std::string>("FEBDelays_file");
  CRTGains_= ps.get<std::string>("CRTgains_file");
  CRTPedestals_= ps.get<std::string>("CRTpedestals_file");
  FEB_MS_delay_= ps.get<std::string>("FEB_MS_delay_file");
  fOffset_ = ps.get<int>("Offset");
  verbose_ = ps.get<int>("verbose");
  Split_ = ps.get<int>("Split");
  WhichHalf_ = ps.get<int>("WhichHalf");
  TopPart_ = ps.get<int>("TopPart");
  PartTop_= ps.get<std::string>("PartTop_file");
  GPSCorrection_ = ps.get<int>("GPSCorrection");
  if(GPSCorrection_==0) CRT_GPS_correction_= ps.get<std::string>("CRT_GPS_correction");
}



void crt::CRTRawInputDetail::readFile(std::string const & filename, art::FileBlock*& fb)
{
  //initialization////////////////////////////////////////////////////////////////////////////////


  crt::auxfunctions::FillPos(SiPMpositions_, sensor_pos); //key = FEB*100+ch  //fill sipm positions      
  crt::auxfunctions::FillFEBDel(FEBDelays_, FEBDel); //key = FEB  //fill FEB delays
  crt::auxfunctions::FillGain(CRTGains_, SiPMgain); //key = FEB*100+ch  //fill sipms gain
  crt::auxfunctions::FillGain(CRTPedestals_, SiPMpedestal); //key = FEB*100+ch  //same for pedestals  
  crt::auxfunctions::FillPartTop(PartTop_,mac_part_top);
  crt::auxfunctions::Init_mspoll_delay(FEB_MS_delay_, Ms_poll);  //fill the factor for poll-ms assignement
  scale_NTP=NTP_deviation(filename);
  if(GPSCorrection_==0 && start_NTP!=0 && end_NTP!=0) crt::auxfunctions::Init_TS0_corr(CRT_GPS_correction_, correctionpoints, start_NTP,end_NTP);
  
  std::cout <<"Run in mode (3=only beam, 11=all): "<< run_mode_ << std::endl; 

  //set all hit counters (from scan buffer and pro buffer) to 0
  for(int i=0;i<MAXFEBNR+1;i++){
    ev_counter_mac[i]=0;
    ev_counter_scan[i]=0;
    ev_counter_filter[i]=0;
    order_buffer[i].flags=1;
    ts1_ref_counter[i]=0;
    ts0ref_counter[i]=0;
    ev_counter_filter_scan[i]=0;
    event_time_diff[i]=0;
    event_time_diff_old[i]=0;
    previous_sec_mac[i]=0;
    number_ms[i]=0;
    last1_ms[i]=0;
    last2_ms[i]=0;
  }
  for(int i=0; i<100;i++){
    ts1ref_counter[i]=0;
    ts1ref_second[i]=0;
  }
  EndOfFile=0; //mark end of file is reached by reading
  previous_sec=0; //store value of previous second
  save_event=0; // scan and receive aslong events untill found coincidencs of 3 diff seconds
  event_counter=0;
  event_ts0=0;
  event_ts1=0;
  tot_events=0;
  previous_sec=0;
  previous_ms_start=0;
  previous_ms_end=0;
  previous_s_start=0;
  previous_s_end=0;
  
  ready_to_fill=PROBUF_READY_TO_FILL;
  ready_to_scan=SCANBUF_READY_TO_FILL;
  //End Initialization ////////////////////////////////////////////////////////////////////////////
  
  //tree stuff: //////////////////////////////////////////////////////////////////////////////////
  my_tree_ = tfs->make<TTree>("my_tree","CRT_Tree");
  my_tree_->Branch("hit_mac_1", &hit_mac_1, "mac1 (s)/I");
  my_tree_->Branch("hit_mac_2", &hit_mac_2, "mac2 (s)/I");
  my_tree_->Branch("hit_time_s", &hit_time_s, "time (s)/D");
  my_tree_->Branch("hit_time_ns", &hit_time_ns, "time (ns)/D");
  my_tree_->Branch("hit_time_ms", &hit_time_ms, "time (ms)/D");
  my_tree_->Branch("beam_time_ns", &beam_time_ns, "beam_time (ns)/D");
  my_tree_->Branch("timediff", &td, "timediff (ns)/D");
  my_tree_->Branch("CRTplane", &plane, "(0=Bot, 1=FT, 2=PS, 3=Top)/i");
  my_tree_->Branch("beam_trigger", &beam_trigger, "beam_trigger/i");
  my_tree_->Branch("pps_trigger", &pps_trigger, "pps_trigger/i");
  my_tree_->Branch("pes_info", &pesmap, "pesmap/D");
  my_tree_->Branch("pestot", &pestot, "pestot/D");
  my_tree_->Branch("Xreco", &xtot, "Xreco (cm)/D");
  my_tree_->Branch("Yreco", &ytot, "Yreco (cm)/D");
  my_tree_->Branch("Zreco", &ztot, "Zreco (cm)/D");
  my_tree_->Branch("Xerr", &xerr, "Xerr (cm)/D");
  my_tree_->Branch("Yerr", &yerr, "Yerr (cm)/D");
  my_tree_->Branch("Zerr", &zerr, "Zerr (cm)/D");

  double inch =2.54; //inch in cm 
  HitDistBot = tfs->make<TH2F>("hBottom","Bottom",125,-700+205*inch,-700+205*inch+125*10.89,60,-300+50.4*inch,-300+50.4*inch+60*10.89);
  HitDistBot->GetXaxis()->SetTitle("Lenght along the beam (cm)");
  HitDistBot->GetYaxis()->SetTitle("Lenght along the drift (cm)");
  HitDistBot->GetZaxis()->SetTitle("Entries/bin");
  HitDistBot->SetOption("COLZ");

  HitDistFT = tfs->make<TH2F>("hFeedthroughSide","Feedthrough Side",125,-704+205*inch,-704+205*inch+125*10.89,60,-308-19.1*inch,-308-19.1*inch+60*10.89);
  HitDistFT->GetXaxis()->SetTitle("Lenght along the beam (cm)");
  HitDistFT->GetYaxis()->SetTitle("Height (cm)");
  HitDistFT->GetZaxis()->SetTitle("Entries/bin");
  HitDistFT->SetOption("COLZ");

  HitDistPipe = tfs->make<TH2F>("hPipeSide","Pipe Side",125,-704+205*inch,-704+205*inch+125*10.89,60,-294-19.1*inch,-294-19.1*inch+60*10.89);
  HitDistPipe->GetXaxis()->SetTitle("Lenght along the beam (cm)");
  HitDistPipe->GetYaxis()->SetTitle("Height (cm)");
  HitDistPipe->GetZaxis()->SetTitle("Entries/bin");
  HitDistPipe->SetOption("COLZ");

  HitDistTop = tfs->make<TH2F>("hTop","Top",125,-701+205*inch,-701+205*inch+125*11.38,80,2-170-300+50.4*inch,2-170-300+50.4*inch+80*11.38);
  HitDistTop->GetXaxis()->SetTitle("Lenght along the beam (cm)");
  HitDistTop->GetYaxis()->SetTitle("Lenght along the drift (cm)"); 
  HitDistTop->GetZaxis()->SetTitle("Entries/bin"); 
  HitDistTop->SetOption("COLZ");

  FEBvsFEB = tfs->make<TH2F>("hFEBvsFEB","FEBvsFEB",130,0,130,130,0,130);
  FEBvsFEB->GetXaxis()->SetTitle("FEB ID");
  FEBvsFEB->GetYaxis()->SetTitle("FEB ID");
  FEBvsFEB->SetOption("COLZ");

  TimeDiff = tfs->make<TH1F>("hCoincidencetimedifference","Coincidence time difference", 400,-200,200);
  TimeDiff->GetXaxis()->SetTitle("Time Difference (ns)");
  TimeDiff->GetYaxis()->SetTitle("Entries/bin");
  
  BeamTime = tfs->make<TH1F>("hBeamEvents","ts1 + offset",250,0,25000);
  BeamTime->GetXaxis()->SetTitle("Time after Beam (ns)");
  BeamTime->GetYaxis()->SetTitle("Entries/bin");

  hxtot = tfs->make<TH1F>("hxtot","xtot",70000,-200,500);
  hxtot->GetXaxis()->SetTitle("Reconstructed X (cm)");
  hxtot->GetYaxis()->SetTitle("Entries/bin");

  hytot = tfs->make<TH1F>("hytot","ytot",60000,-300,300);
  hytot->GetXaxis()->SetTitle("Reconstructed Y (cm)");
  hytot->GetYaxis()->SetTitle("Entries/bin");

  hztot = tfs->make<TH1F>("hztot","ztot",130000,-100,1200);
  hztot->GetXaxis()->SetTitle("Reconstructed Z (cm)");
  hztot->GetYaxis()->SetTitle("Entries/bin");

  hPES = tfs->make<TH1F>("hPES","PES",150,0,150);
  hPES->GetXaxis()->SetTitle(" pes");
  hPES->GetYaxis()->SetTitle("Entries/bin");

  hPEStot = tfs->make<TH1F>("hPEStot","PEStot",500,0,500);
  hPEStot->GetXaxis()->SetTitle(" pestot");
  hPEStot->GetYaxis()->SetTitle("Entries/bin");
  //end tree stuff /////////////////////////////////////////////////////////////////////////////////////////////
  
  fb = new art::FileBlock(art::FileFormatVersion(1, "RawEvent2011"), filename);
  //load raw file names: 4 files only for Testing!!!!!!!!!!!!

  if(NrFiles_==0){
    data1=fopen(filename.c_str(),"r");
    fseek(data1, 0, SEEK_END); // seek to end of file
    long size1 = ftell(data1); // get current file pointer
    fseek(data1, 0, SEEK_SET); // seek back to beginning of file
    size_ev=size1/sizeof(EVENT_t);		//number of total events
    if(Split_==1 && WhichHalf_==1) size_ev=size_ev/2;
    if(Split_==1 && WhichHalf_==2) fseek(data1, (size_ev/2+1)*sizeof(EVENT_t), SEEK_SET);
    printf("Total Number of events: %ld\n",size_ev);
    read_events1=1000;
    read_events2=0;
    read_events3=0;
    read_events4=0;
    return;
  }

  fInputStreamList.open(filename.c_str(),std::ios_base::in);

  if(NrFiles_==1){
    std::string input_temp1;
    if (fInputStreamList.good()){
      getline(fInputStreamList, input_temp1);
      std::cout << "Open raw data file: " << input_temp1 << std::endl;
    }
    fInputStreamList.close();
    const char *input1 = input_temp1.c_str();
    data1=fopen(input1,"r");
    fseek(data1, 0, SEEK_END); // seek to end of file
    long size1 = ftell(data1); // get current file pointer
    fseek(data1, 0, SEEK_SET); // seek back to beginning of file
    size_ev=size1/sizeof(EVENT_t);		//number of total events
    if(Split_==1 && WhichHalf_==1) size_ev=size_ev/2;
    if(Split_==1 && WhichHalf_==2) fseek(data1, (size_ev/2+1)*sizeof(EVENT_t), SEEK_SET);
    printf("Total Number of events: %ld\n",size_ev);
    read_events1=1000;
    read_events2=0;
    read_events3=0;
    read_events4=0;
  }
  if(NrFiles_==4){
    std::string input_temp1;
    std::string input_temp2;
    std::string input_temp3;
    std::string input_temp4;
    if (fInputStreamList.good()){
      getline(fInputStreamList, input_temp1);
      getline(fInputStreamList, input_temp2);
      getline(fInputStreamList, input_temp3);
      getline(fInputStreamList, input_temp4);
      std::cout << "Open raw data file: "<< input_temp1 << std::endl;
      std::cout << "Open raw data file: "<< input_temp2 << std::endl;
      std::cout << "Open raw data file: "<< input_temp3 << std::endl;
      std::cout << "Open raw data file: "<< input_temp4 << std::endl;
    }
    fInputStreamList.close();

    const char *input1 = input_temp1.c_str();
    const char *input2 = input_temp2.c_str();
    const char *input3 = input_temp3.c_str();
    const char *input4 = input_temp4.c_str();

    data1=fopen(input1,"r");
    fseek(data1, 0, SEEK_END); // seek to end of file
    long size1 = ftell(data1); // get current file pointer
    fseek(data1, 0, SEEK_SET); // seek back to beginning of file

    data2=fopen(input2,"r");
    fseek(data2, 0, SEEK_END); // seek to end of file
    long size2 = ftell(data2); // get current file pointer
    fseek(data2, 0, SEEK_SET); // seek back to beginning of file

    data3=fopen(input3,"r");
    fseek(data3, 0, SEEK_END); // seek to end of file
    long size3 = ftell(data3); // get current file pointer
    fseek(data3, 0, SEEK_SET); // seek back to beginning of file

    data4=fopen(input4,"r");
    fseek(data4, 0, SEEK_END); // seek to end of file
    long size4 = ftell(data4); // get current file pointer
    fseek(data4, 0, SEEK_SET); // seek back to beginning of file

    size_ev=size4/sizeof(EVENT_t);		//number of total events
    printf("Total Number of events: %ld\n",size_ev);

    read_events4=1000;
    read_events1=(double)size1/size4*read_events4+0.5;
    read_events2=(double)size2/size4*read_events4+0.5;
    read_events3=(double)size3/size4*read_events4+0.5;
    //std::cout << size1 << " - " <<read_events1<< std::endl;
    //std::cout << size2 << " - " <<read_events2<< std::endl;
    //std::cout << size3 << " - " <<read_events3<< std::endl;
    //std::cout << size4 << " - " <<read_events4<< std::endl;
  }
}


void crt::CRTRawInputDetail::closeCurrentFile()
{
  for(auto & stream : fInputStreams)
    stream.close();
  fInputStreamList.close();
}

bool crt::CRTRawInputDetail::readNext(art::RunPrincipal const* const inR, art::SubRunPrincipal const* const inSR,
				      art::RunPrincipal*& outR, art::SubRunPrincipal*& outSR, art::EventPrincipal*& outE){
  //main loop until all 2d hits of a second are found //////////////////////////////////////////////
  //std::cout << "Read Next event " << std::endl;
  while(save_event!=1 && EndOfFile==0){   //endless loop over all events receiving   
    //If one pro buffer is full->scan the whole buffer without scaling, else print status of buffer
    for(int i=0;i<MAXFEBNR;i++){
      if(ev_counter_mac[i]>(4*EVSPERFEB)){  //test if there is an overflow in the receiving buffer
        printf("pro buffer scaned and reseted without scaling of %d...\n",i);
        shift_scale(i, 4*EVSPERFEB, 1e9);
        ready_to_fill=PROBUF_READY_TO_FILL;
        ev_counter_mac[i]=0;  //if one buffer is overload, it is scaled w/out scaling...
      }
      else if(ev_counter_mac[i]!=0){ //if everything if fine, print the number of events in the buffers
        //printf("fill status of %d: %d - %d\n",i,ev_counter_mac[i], ev_counter_scan[i]);
      }
    }


    //receive new data
    if(ready_to_fill==PROBUF_READY_TO_FILL){
      ready_to_fill=PROBUF_FILLING;
      receive_data();}
    //scale and scan the new data
    if(ready_to_fill==PROBUF_READY_TO_SCALE){
      ready_to_fill=PROBUF_SHIFT_SCALE;
      scale_buffer();   //in case more than one second is in the buffer
    }
    else{ printf("pro buffer is in use... \n");}
    while(ready_to_fill!=PROBUF_READY_TO_SCALE && ready_to_fill!=PROBUF_READY_TO_FILL){ printf("Error, Buffers not ready!... \n");}
  }
  //std::cout << "end main loop " << std::endl;
  //end main loop////////////////////////////////////////////////////////////////////////////////////////
  
  //for the end of the file is reached: process everything in the buffer w/o scaling and look for events in the last seconds///
  if(EndOfFile==1){ //process everything in the buffer without scaling (not total seconds)
    for(int i=0; i<MAXFEBNR; i++){
      shift_scale(i, ev_counter_mac[i], 1e9);
    }
    EndOfFile=2;
  }   
  else if(EndOfFile==2){//look for events in the last seconds
      if((allmyCRTHits[allmyCRTHits.size()-1].ts0_s-allmyCRTHits[0].ts0_s)>0){
      save_event=1;
      uint32_t this_sec=allmyCRTHits[0].ts0_s;
      int hit_counter=0;
      for(unsigned int i=0; i<allmyCRTHits.size(); i++){
        if(allmyCRTHits[i].ts0_s==this_sec){
          allCRTHits.push_back(allmyCRTHits[i]);
          hit_counter++;
        }
      }
      int stop=allmyCRTHits.size();
      for(int i=0; i<stop; i++){
        if(allmyCRTHits[i].ts0_s==this_sec){
          allmyCRTHits.erase (allmyCRTHits.begin()+i);
          i--;
          stop--;
        }  
      }
      total_hits+=hit_counter;
      if(verbose_==1) std::cout<<"Found: " << hit_counter << " of " << total_hits << " int the second: "<< this_sec  << " End: "<< EndOfFile<<std::endl;
    }
    else{
      int hit_counter=0;
      for(unsigned int i=0; i<allmyCRTHits.size(); i++){
        allCRTHits.push_back(allmyCRTHits[i]);
        hit_counter++;
      }
       allmyCRTHits.erase (allmyCRTHits.begin(), allmyCRTHits.end());
      total_hits+=hit_counter;
      uint32_t this_sec=allmyCRTHits[0].ts0_s;
      if(verbose_==1) std::cout<<"Found: " << hit_counter << " of " << total_hits << " int the second: "<< this_sec << " End: "<< EndOfFile << std::endl << " no more hits in the file" << std::endl;
    }
  }//end of end of file treatment///////////////////////////////////////////////////////////////////////////////////////////////
  
  //write the event...///////////////////////////////////////////
  std::unique_ptr<std::vector<crt::CRTHit> > CRTHiteventCol(new std::vector<crt::CRTHit>); //collection of CRTHits 
  for(std::vector<int>::size_type i = 0; i != allCRTHits.size(); i++){
    crt::CRTHit CRTHitevent = allCRTHits[i];
    CRTHiteventCol->emplace_back(CRTHitevent);
    
    if(verbose_==1){
      std::cout<<"CRTHitevent.xpos:  "<<CRTHitevent.x_pos<<std::endl;
      std::cout<<"CRTHitevent.ypos:  "<<CRTHitevent.y_pos<<std::endl;
      std::cout<<"CRTHitevent.zpos:  "<<CRTHitevent.z_pos<<std::endl;
      std::cout<<"CRTHitevent.ts0_s:  "<<CRTHitevent.ts0_s<<std::endl;
      std::cout<<"CRTHitevent.ts0_ns:  "<<CRTHitevent.ts0_ns<<std::endl;
      std::cout<<"CRTHitevent.ts1_ns:  "<<CRTHitevent.ts1_ns<<std::endl;
      getchar();
    }
  }
  
  //uint64_t const& v_crt_time = allCRTHits[0].ts0_s;//e.first; //how to add here the second???? //first second on run????
  uint64_t const& v_crt_time = allCRTHits[0].ts0_s*0x100000000 ;//e.first; //how to add here the second???? //first second on run????
  size_t run_num = 1;
  size_t subrun_num = 1;
  if(run_num!=fPrevRunNumber){
      outR = fSourceHelper.makeRunPrincipal(run_num,v_crt_time);//time of this second????
      outSR = fSourceHelper.makeSubRunPrincipal(run_num,subrun_num,v_crt_time);
      fPrevRunNumber = run_num;
      fPrevSubRunNumber =subrun_num;
    }
  else if(subrun_num!=fPrevSubRunNumber){
      outSR = fSourceHelper.makeSubRunPrincipal(run_num,subrun_num,v_crt_time);
      fPrevSubRunNumber =subrun_num;
    }
  outE = fSourceHelper.makeEventPrincipal(run_num, subrun_num, fEventNumber++, v_crt_time);
  event_counter++;
  if(event_counter%1==0 && verbose_==1){
    const time_t ctt = time(0);
    std::cout<<"Wrote event Nr: "<< event_counter << " at: " << asctime(localtime(&ctt));
    std::cout<<"Found total: " << total_hits << " in the second: "<< allCRTHits[0].ts0_s <<std::endl;
  }
  //evt.put(std::move(CRTHiteventCol));
  art::put_product_in_principal(std::move(CRTHiteventCol),*outE, fModuleLabel, fInstanceLabel);
  allCRTHits.erase(allCRTHits.begin(), allCRTHits.end());
  save_event=0;
  if(verbose_==1){
    std::cout<<" "<<std::endl;
    std::cout<<"allCRTHits.size():  "<<allCRTHits.size()<<std::endl;
  } //end write event/////////////////////////////////////////////////////
  return true;
}

//read hits from the modules////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void crt::CRTRawInputDetail::receive_data(){
  //std::cout<<"receive data" <<std::endl;
  int mac=0;
  for(int i=0;i<read_events1;i++){
    if(fread(&evbuf[i],sizeof(EVENT_t),1,data1)<=0){EndOfFile=1; break;}
  }
  for(int i=0;i<read_events2;i++){
    if(fread(&evbuf[i+read_events1],sizeof(EVENT_t),1,data2)<=0){EndOfFile=1; break;}
  }
  for(int i=0;i<read_events3;i++){
    if(fread(&evbuf[i+read_events1+read_events2],sizeof(EVENT_t),1,data3)<=0){EndOfFile=1; break;}
  }
  for(int i=0;i<read_events4;i++){
    if(fread(&evbuf[i+read_events1+read_events2+read_events3],sizeof(EVENT_t),1,data4)<=0){EndOfFile=1; break;}
  }
  int received_events=read_events1+read_events2+read_events3+read_events4;
  tot_events+=received_events;
  if(Split_==1){
    if(WhichHalf_==1 && size_ev<tot_events) EndOfFile=1;
  }
  //int reassign=0;//control number for changes in second assignement
  int all_fine=0;//control number if the jump happened after a reference pulse
	int proceed=1;
  int start_ms=0,end_ms=0,start_sec=0,end_sec=0;
  
  for(int i=0; i<received_events; i++){
    proceed=1;
    for(int z=0; z<mac_part_top[TopPart_][99]; z++){
			if(evbuf[i].mac5==mac_part_top[TopPart_][z]){
				proceed=0;
			}
		}
    if(evbuf[i].mac5==0xFFFF){    //reads the spezial event
      memcpy(&refevent,&evbuf[i].mac5,sizeof(EOP_EVENT_t));
      //previous_sec=act_time[0][MAXFEBNR];
      //previous_ms=act_time[1][MAXFEBNR]%1000;
      //act_time[0][MAXFEBNR]=(int)refevent.end_s;
      //act_time[1][MAXFEBNR]=(int)refevent.end_ms;
      start_ms=previous_ms_start;
      end_ms=previous_ms_end;
      start_sec=previous_s_start;
      end_sec=previous_s_end;
      
      int this_start_ms=(int)refevent.start_ms;
      int this_end_ms=(int)refevent.end_ms;
			int this_start_sec=(int)refevent.start_s;
			int this_end_sec=(int)refevent.end_s;
      
      previous_ms_start=this_start_ms;
      previous_ms_end=this_end_ms;
      previous_s_end=this_end_sec;
      previous_s_start=this_start_sec;
      //printf("Previous:	%d seconds	%d millisec\n",previous_sec, previous_ms_start);
			//printf("Start:	%d seconds	%d millisec\n",start_sec, start_ms);
      //printf("End:	%d seconds	%d millisec\n",(int)refevent.end_s, refevent.end_ms);
      if(start_sec!=end_sec) end_ms+=1e3;
      
      for(int febnr=0;febnr<MAXFEBNR;febnr++){ //A loof over all FEB
				
        if(ev_counter_mac[febnr]>0){  //B assign ms and second to first event after poll
          int first_newevent=0;
          while(evbuf_pro[febnr][first_newevent].sec!=0){
            first_newevent++;
          }
            
				  int this_ms = (start_ms +(int)(((end_ms-start_ms)*Ms_poll[febnr])+0.5));
					//int this_ms = (start_ms +(int)((end_ms-start_ms)*1));
          this_ms=this_ms + (int)(scale_NTP*((long)start_NTP-start_sec));
          int this_ts0=evbuf_pro[febnr][first_newevent].ts0;
					
          if(start_sec==end_sec || this_ms>1000) evbuf_pro[febnr][first_newevent].sec=end_sec;
					else evbuf_pro[febnr][first_newevent].sec=start_sec;					
          evbuf_pro[febnr][first_newevent].ms=this_ms%1000;
					//if(febnr==max_mac) printf("this_ms: %d, MS_pollfactor: %lf, start:, %d, end: %d\n", this_ms, Ms_poll[febnr], start_ms, end_ms);
          for( int j=first_newevent+1; j<ev_counter_mac[febnr]; j++){  //C assign all corrected ms and sec
            if(evbuf_pro[febnr][j].sec!=0) break;
            int delta_ts0 = this_ts0-evbuf_pro[febnr][j].ts0;
            if((int)evbuf_pro[febnr][j].ts0>this_ts0) delta_ts0 = 1e9+this_ts0-evbuf_pro[febnr][j].ts0;
            int event_ms=(this_ms-(int)(delta_ts0/1e6+0.5))%1000;
						if(event_ms>0) evbuf_pro[febnr][j].ms=event_ms;
						else evbuf_pro[febnr][j].ms=event_ms+1e3;
						evbuf_pro[febnr][j].sec=evbuf_pro[febnr][first_newevent].sec;
						if(end_sec!=start_sec && evbuf_pro[febnr][j].ms<200){
							evbuf_pro[febnr][j].sec+=1;
						}
						else if(event_ms<=0){
							evbuf_pro[febnr][j].sec-=1;
						}
             //if(febnr==max_mac)printf("i: %d, mac: %d,ts0: %d,  event_ms: %d, event_s: %d, previous_sec %d, previous_ms: %d, poll_ms: %d\n",j,febnr, evbuf_pro[febnr][j].ts0, evbuf_pro[febnr][j].ms,evbuf_pro[febnr][j].sec, previous_sec,previous_ms, end_ms);
            //implement ts1_ref crecovery here...
            if((evbuf_pro[febnr][j-1].flags==3 || evbuf_pro[febnr][j-1].flags==1) || evbuf_pro[febnr][j-1].lostcpu==99){
              int event_time_diff_now=evbuf_pro[febnr][j].ts0-evbuf_pro[febnr][j].ts1;
              int one_back=0;
              int event_time_diff_old;
              do{
                one_back++;
                //printf("one_back: %d -> lostcpu: %d\n",one_back,evbuf_pro[febnr][j-one_back].lostcpu);
                event_time_diff_old=evbuf_pro[febnr][j-one_back].ts0-evbuf_pro[febnr][j-one_back].ts1; //what when this is a stucked event???
              } while(evbuf_pro[febnr][j-one_back].lostcpu==99 && (j-one_back)>0);
              if(std::abs(event_time_diff_old-event_time_diff_now)>500){ // the jump has to be bigger than 500
                all_fine=0;
                //check for what referent event was missed or if it was a stucked event...
                if(std::abs(event_time_diff_old-event_time_diff_now-1e9)<30000){ //check if ts0_ref was missed 30us > dead time FEB
                  if(evbuf_pro[febnr][j-one_back].flags==5 || evbuf_pro[febnr][j-one_back].flags==7) all_fine=1;
                  if(all_fine!=1){
                    for(int counter=ev_counter_mac[febnr]; counter>=j; counter--){ //shift all events after one further
                      evbuf_pro[febnr][counter+1]=evbuf_pro[febnr][counter];
                    }
                    ts0ref_counter[febnr]++;
                    //assign new event at the right place with ts0 = 1e9 (no scaling)
                    evbuf_pro[febnr][j].sec=evbuf_pro[febnr][j-one_back].sec;
                    evbuf_pro[febnr][j].ms=evbuf_pro[febnr][j-one_back].ms;
                    evbuf_pro[febnr][j].mac5=febnr;
                    evbuf_pro[febnr][j].flags=7;
                    evbuf_pro[febnr][j].ts0=1e9;
                    evbuf_pro[febnr][j].ts1=evbuf_pro[febnr][j-one_back].ts1+(1e9-evbuf_pro[febnr][j-one_back].ts0);
                    for(int amp=0; amp<32;amp++) evbuf_pro[febnr][j].adc[amp]=0;
                    evbuf_pro[febnr][j].ts0_scaled=0;
                    evbuf_pro[febnr][j].ts0_ref=0;
                    evbuf_pro[febnr][j].lostcpu=0;
                    evbuf_pro[febnr][j].lostfpga=0;
                    evbuf_pro[febnr][j].recover=1;
                    ev_counter_mac[febnr]++;
                  }
                } //    (e
                else if(evbuf_pro[febnr][j].ts1<(evbuf_pro[febnr][j].ts0-evbuf_pro[febnr][j-one_back].ts0+20) && evbuf_pro[febnr][j].ts0>evbuf_pro[febnr][j-one_back].ts0 && evbuf_pro[febnr][j].ts1<evbuf_pro[febnr][j-one_back].ts1){ //check if ts1_ref 
                  if(evbuf_pro[febnr][j-one_back].flags==10 || evbuf_pro[febnr][j-one_back].flags==11) all_fine=1;
                  if(all_fine!=1){
                    if(my_abs(evbuf_pro[febnr][j].ts0,(evbuf_pro[febnr][j-one_back].ts0+evbuf_pro[febnr][j].ts1))<20){evbuf_pro[febnr][j-one_back].flags=11;} //1. check if there is an event with wrong assigned flag
                    else if((evbuf_pro[febnr][j].ts0-evbuf_pro[febnr][j-one_back].ts0)<1e8){  //2. if no event is there add new event; check if stucked event...
                      for(int counter=ev_counter_mac[febnr]; counter>=j; counter--){ //shift all events after one further
                        evbuf_pro[febnr][counter+1]=evbuf_pro[febnr][counter];
                      }
                      evbuf_pro[febnr][j].sec=evbuf_pro[febnr][j-one_back].sec;
                      evbuf_pro[febnr][j].ms=evbuf_pro[febnr][j-one_back].ms;
                      evbuf_pro[febnr][j].mac5=febnr;
                      evbuf_pro[febnr][j].flags=11;
                      evbuf_pro[febnr][j].ts0=evbuf_pro[febnr][j+1].ts0-evbuf_pro[febnr][j+1].ts1;
                      evbuf_pro[febnr][j].ts1=evbuf_pro[febnr][j-one_back].ts1+(evbuf_pro[febnr][j+1].ts0-evbuf_pro[febnr][j+1].ts1-evbuf_pro[febnr][j-one_back].ts0);
                      for(int amp=0; amp<32;amp++) evbuf_pro[febnr][j].adc[amp]=0;
                      evbuf_pro[febnr][j].ts0_scaled=0;
                      evbuf_pro[febnr][j].ts0_ref=0;
                      evbuf_pro[febnr][j].lostcpu=0;
                      evbuf_pro[febnr][j].lostfpga=0;
                      evbuf_pro[febnr][j].recover=1;
                      ev_counter_mac[febnr]++;
                      //std::cout << "found ts1_ref and inserted it..." <<  std::setw(9)<< evbuf[i].ts1 << " ts1 "<<  std::setw(9)<< event_ts1 << " ts1old "<<  std::setw(9)<< evbuf[i].ts0 << " ts0 "<<  std::setw(9)<< event_ts0<< " ts0_old" << std::endl;
                    }
                  }
                }
                else {  //it has to be a stucked event. Count them for statistic, asign something special to it...
                  //evbuf_pro[febnr][j].lostcpu=99;
                  //stuck_event_counter++;
                }
                
                
                
              }
            }
            
          } //C
        }  //B
      }  //A
    }
    else if(proceed==1){
      //only fill all the other variables to here || check when looking for ts0_ref to check for assigned ms and sec!!!
      mac=evbuf[i].mac5; 
      if(evbuf[i].flags==5 || evbuf[i].flags==7) ts0ref_counter[mac]++;
      
      evbuf_pro[mac][ev_counter_mac[mac]].sec=0;
      evbuf_pro[mac][ev_counter_mac[mac]].ms=0;
      evbuf_pro[mac][ev_counter_mac[mac]].mac5=mac;
      evbuf_pro[mac][ev_counter_mac[mac]].flags=evbuf[i].flags;
      evbuf_pro[mac][ev_counter_mac[mac]].ts0=evbuf[i].ts0;
      evbuf_pro[mac][ev_counter_mac[mac]].ts1=evbuf[i].ts1;
      for(int j=0; j<32;j++) evbuf_pro[mac][ev_counter_mac[mac]].adc[j]=evbuf[i].adc[j];
      evbuf_pro[mac][ev_counter_mac[mac]].ts0_scaled=0;
      evbuf_pro[mac][ev_counter_mac[mac]].ts0_ref=0;    //not really used
	    evbuf_pro[mac][ev_counter_mac[mac]].recover=0;  
      evbuf_pro[mac][ev_counter_mac[mac]].lostcpu=evbuf[i].lostcpu;
      evbuf_pro[mac][ev_counter_mac[mac]].lostfpga=evbuf[i].lostfpga;
      evbuf_pro[mac][ev_counter_mac[mac]].nrtrigger_11=ts0ref_counter[mac];
      //evbuf_pro[mac][ev_counter_mac[mac]].nrtrigger=ts1ref_counter[mac];
      ev_counter_mac[mac]++;
      
    }
  }
  ready_to_fill=PROBUF_READY_TO_SCALE;
}
//searches referent events (produced throw PPS) and process them further////////////////////////////////////////////////////////////////////
void crt::CRTRawInputDetail::scale_buffer(){
  //std::cout<<"scale data" <<std::endl;
  for(int j=0;j<MAXFEBNR;j++){ //loop over all planes
   for(int i=0;i<ev_counter_mac[j];i++){  
    if((evbuf_pro[j][i].flags==5 || evbuf_pro[j][i].flags==7) && evbuf_pro[j][i].sec!=0){ //search a time ref event
      if(ready_to_scan==SCANBUF_READY_TO_FILL){
        order_buffer[j].sec=evbuf_pro[j][i].sec;
        order_buffer[j].ref_nr=i;
        order_buffer[j].ts0_ref=evbuf_pro[j][i].ts0;
        order_buffer[j].flags=0;
      }
      else {printf("Buffer not ready to scan!!\n"); 
           }
      i=ev_counter_mac[j];  //to go of the for loop
      break;
    }
   }   
  }
  //the following part looks that the buffers with sec<sec_max is scaned first/////
  uint32_t sec_max=0;
  for(int j=0;j<MAXFEBNR+1;j++){  //find max_sec
    if(order_buffer[j].flags==0 && order_buffer[j].sec>sec_max) sec_max=order_buffer[j].sec;
  } 
  //Scan the buffer first with second < max_second in the buffer
  for(int j=0;j<MAXFEBNR+1;j++){  //scale/scan all seconds < max_sec
    if(order_buffer[j].flags==0 && order_buffer[j].sec <sec_max){
      ready_to_scan=SCANBUF_SCANNING;
	  //if((sec_max-order_buffer[j].sec)>1) printf("\nsec1: %d, sec_max: %d\n",order_buffer[j].sec,sec_max);
      shift_scale(j,order_buffer[j].ref_nr,order_buffer[j].ts0_ref);
      order_buffer[j].ts0_ref=0;
      order_buffer[j].flags=1;
    }
  }
  for(int j=0;j<MAXFEBNR+1;j++){  //scan seconds with max_sec
   if(order_buffer[j].flags==0){
     ready_to_scan=SCANBUF_SCANNING;
     shift_scale(j,order_buffer[j].ref_nr,order_buffer[j].ts0_ref);
     order_buffer[j].ts0_ref=0;
     order_buffer[j].flags=1;
   }
  }
  ready_to_fill=PROBUF_READY_TO_FILL;
}
//if a hole second is present in the processing buffer the hits are copyed and scaled for scanning//////////////////////////////////////////
void crt::CRTRawInputDetail::shift_scale(int mac, int ref_nr, int ts0_ref){ //scale all events and store them in the scan buffer
  //std::cout<<"shift scale data" <<std::endl;
  for(int i=0; i< number_ms[mac];i++){
    evbuf_scan[mac][i]=evbuf_scan[mac][ev_counter_scan[mac]-number_ms[mac]+i];
  }
  for(int i=0;i<ref_nr;i++){ //loop over all hits of a plane
    evbuf_scan[mac][i+number_ms[mac]]=evbuf_pro[mac][i];    //shift the hit from the pro to the scan buffer
    long scale0=((evbuf_pro[mac][i].ts0*1e9)/ts0_ref+0.5);  //calculate the scaling factor
    long scale1=((evbuf_pro[mac][i].ts1*1e9)/ts0_ref+0.5);  //calculate the scaling factor
    evbuf_scan[mac][i+number_ms[mac]].ts0_scaled=(int)scale0;    //store the scaled value
    evbuf_scan[mac][i+number_ms[mac]].ts1_scaled=(int)scale1;    //store the scaled value
    evbuf_scan[mac][i+number_ms[mac]].ts0_ref=ts0_ref; 
    //GPS correction is done here
    if(GPSCorrection_==0){
      for(int counter_corr=0; counter_corr<49; counter_corr++){
        if(correctionpoints[counter_corr].sec<evbuf_scan[mac][i+number_ms[mac]].sec && correctionpoints[counter_corr+1].sec>evbuf_scan[mac][i+number_ms[mac]].sec){
          long ts0_corr = (int)evbuf_scan[mac][i+number_ms[mac]].ts0_scaled+(int)(correctionpoints[counter_corr].offset+(correctionpoints[counter_corr+1].offset-correctionpoints[counter_corr].offset)/(correctionpoints[counter_corr+1].sec-correctionpoints[counter_corr].sec)*(evbuf_scan[mac][i+number_ms[mac]].sec-correctionpoints[counter_corr].sec));
          while(ts0_corr>1e9) ts0_corr-=1e9;
          while(ts0_corr<0) ts0_corr+=1e9;        
          evbuf_scan[mac][i+number_ms[mac]].ts0_corr=(unsigned int)ts0_corr;

          //evbuf_scan[mac][i+number_ms[mac]].lostfpga=88;
          //printf("-------------------------------------------------------------------\n");
          counter_corr=50;
        }
        else if(correctionpoints[counter_corr].sec!=0 && correctionpoints[counter_corr+1].sec==0){
          long ts0_corr = (int)evbuf_scan[mac][i+number_ms[mac]].ts0_scaled+(int)(correctionpoints[counter_corr].offset+(correctionpoints[counter_corr].scale)*(evbuf_scan[mac][i+number_ms[mac]].sec-correctionpoints[counter_corr].sec));
          while(ts0_corr>1e9) ts0_corr-=1e9;
          while(ts0_corr<0) ts0_corr+=1e9;        
          evbuf_scan[mac][i+number_ms[mac]].ts0_corr=(unsigned int)ts0_corr;

          //evbuf_scan[mac][i+number_ms[mac]].lostfpga=88;
          //printf("-------------------------------------------------------------------\n");
          counter_corr=50;
        }
        //if(counter_corr!=50) printf(" %d - ",counter_corr);
      }
    }
    else if(GPSCorrection_==1){
      long ts0_corr = (int)evbuf_scan[mac][i+number_ms[mac]].ts0_scaled+(int)crt::auxfunctions::CRT_Only_Offset(evbuf_scan[mac][i+number_ms[mac]].sec);
      while(ts0_corr>1e9) ts0_corr-=1e9;
      while(ts0_corr<0) ts0_corr+=1e9; 
      evbuf_scan[mac][i+number_ms[mac]].ts0_corr=(unsigned int)ts0_corr;
    }
    evbuf_scan[mac][i+number_ms[mac]].ts0_ref=ts0_ref; 
   evbuf_scan[mac][i+number_ms[mac]].sec_corr=evbuf_scan[mac][i+number_ms[mac]].sec;
    
    if(my_abs(evbuf_scan[mac][i+number_ms[mac]].ms,(int)(evbuf_scan[mac][i+number_ms[mac]].ts0_corr/1e6))>800){
     //printf("ms %d, ts0 %d, diff: %d, sec: %d\n", evbuf_scan[mac][i+number_ms[mac]].ms, (int)(evbuf_scan[mac][i+number_ms[mac]].ts0_corr/1e6), my_abs(evbuf_scan[mac][i+number_ms[mac]].ms,(int)(evbuf_scan[mac][i+number_ms[mac]].ts0_corr/1e6)), evbuf_scan[mac][i+number_ms[mac]].sec_corr);
     if(evbuf_scan[mac][i+number_ms[mac]].ms<((int)(evbuf_scan[mac][i+number_ms[mac]].ts0_corr/1e6))) evbuf_scan[mac][i+number_ms[mac]].sec_corr-=1;
     if(evbuf_scan[mac][i+number_ms[mac]].ms>((int)(evbuf_scan[mac][i+number_ms[mac]].ts0_corr/1e6))) evbuf_scan[mac][i+number_ms[mac]].sec_corr+=1;
     //evbuf_scan[mac][i+number_ms[mac]].sec_corr-=1;
   }
 }
  
  
  
  
 for(int i=ref_nr+1;i<ev_counter_mac[mac];i++){ //shift the rest to the beginnig of the pro buffer
  evbuf_pro[mac][i-ref_nr-1]=evbuf_pro[mac][i];
 }
 ev_counter_mac[mac]=ev_counter_mac[mac]-ref_nr-1;  //set the hit counter of the pro buffer
 ev_counter_scan[mac]=ref_nr+number_ms[mac]; //set the hit counter of the scan buffer
  //filters first only beam events and then eventuall looking  for pairs
 filter_buffer(mac);
 scan_buffer_filter(mac); 
}
//add an overlapping part (~ms) to the events for finding coincidence over a second/ beam in new second...//////////////////////////////////
void crt::CRTRawInputDetail::scan_buffer_filter(int mac){  //scan over all events of one plane over one sec and search all possible coincidences
  //std::cout<<"scan filter data" <<std::endl;
  last2_ms[mac]=0;
  uint32_t second = evbuf_scan[mac][ev_counter_scan[mac]-1].sec;
  if(ts1ref_second[second%100]!=second){
    ts1ref_counter[second%100]=0;
    ts1ref_second[second%100]=second;
  }
  
  int filter_counter=0;
  for(int i=last1_ms[mac];i<ev_counter_scan[mac];i++){
    //copy events in buffer for filtering
    evbuf_filter[mac][filter_counter]=evbuf_scan[mac][i];
    filter_counter++;
    //set last2_ms
    if(evbuf_scan[mac][i].ts0>=(1e9-2*MSOVERLAP) && i>number_ms[mac]){
      if(last2_ms[mac]==0){
        last2_ms[mac]=i;
      }
    }
    //set last1_ms
    if((evbuf_scan[mac][i].ts0>=(1e9-MSOVERLAP) && i>number_ms[mac])||i==(ev_counter_scan[mac]-1)){
      if(last2_ms[mac]==0) last2_ms[mac]=i;
      last1_ms[mac]=i;
      number_ms[mac]=ev_counter_scan[mac]-last2_ms[mac];
      last1_ms[mac]=last1_ms[mac]-last2_ms[mac];
      break;
    }
    if(evbuf_scan[mac][i].flags==10 || evbuf_scan[mac][i].flags==11){
      int new_ts1ref=1;
      for(int j=0;j<ts1ref_counter[second%100];j++){
        if(my_abs(evbuf_scan[mac][i].ts0,ts1ref_buffer[second%100][j])<20000) new_ts1ref++;
      }
      if(new_ts1ref==1){
        ts1ref_buffer[second%100][ts1ref_counter[second%100]]=evbuf_scan[mac][i].ts0;
        ts1ref_counter[second%100]++;
      }
    }
  }
  ready_to_scan=SCANBUF_READY_TO_FILL;
  ev_counter_filter[mac]=filter_counter;
}
// filter beam events/correct the ts1 to minus//////////////////////////////////////////////////////////////////////////////////////////////
void crt::CRTRawInputDetail::filter_buffer(int mac){
  //std::cout<<"filter data" <<std::endl;
  int second = evbuf_filter[mac][ev_counter_filter[mac]-1].sec;
  int beam_ev_counter=0;
  uint32_t ts1_ref_approved[100][2];
  int approved_ts1ref=0;
  for(int i=0; i<ev_counter_filter[mac];i++){
    for(int j=0;j<ts1ref_counter[second%100];j++){
      if(my_abs((evbuf_filter[mac][i].ts0),ts1ref_buffer[second%100][j])<50){
        //check if ts1_ref is also an event without flags in this second
        ts1_ref_counter[mac]++;
        ts1_ref_approved[approved_ts1ref][1]=0; //0= not recovered
        ts1_ref_approved[approved_ts1ref][0]=ts1ref_buffer[second%100][j];
        if(evbuf_filter[mac][i].flags!=11) {
          evbuf_filter[mac][i].flags = evbuf_filter[mac][i].flags | 0x100;
          ts1_ref_approved[approved_ts1ref][1]=1;}//1= recovered
        approved_ts1ref++;
      }
    }
  }
  if(run_mode_==TS1_CORR){ //just assigne new ts1 for all events 6ms for beam trigger event.
    for(int i=0; i<ev_counter_filter[mac];i++){
      for(int j=0;j<approved_ts1ref;j++){
        if((ts1_ref_approved[j][0]-evbuf_filter[mac][i].ts0)<6e6 && (ts1_ref_approved[j][0]>evbuf_filter[mac][i].ts0)){     
            evbuf_filter[mac][i].ts1=4e9+ts1_ref_approved[j][0]-evbuf_filter[mac][i].ts0;
        }
      }
    }
    for(int i=0; i<ev_counter_filter[mac];i++){
      evbuf_filter_scan[mac][i]=evbuf_filter[mac][i];
      evbuf_filter_scan[mac][i].nrtrigger=ts1_ref_counter[mac];
    }
  }
  
  if(run_mode_==FILTER_PAIR_MODE){
    for(int i=0; i<ev_counter_filter[mac];i++){
      for(int j=0;j<approved_ts1ref;j++){
        if(((ts1_ref_approved[j][0]>evbuf_filter[mac][i].ts0) && (ts1_ref_approved[j][0]-evbuf_filter[mac][i].ts0)<MAX_TIME_PREBEAM) ||
           ((ts1_ref_approved[j][0]<=evbuf_filter[mac][i].ts0) && (evbuf_filter[mac][i].ts0-ts1_ref_approved[j][0])<MAX_TIME_PASTBEAM)){

          evbuf_filter_scan[mac][beam_ev_counter]=evbuf_filter[mac][i];
          if(ts1_ref_approved[j][1]==1) evbuf_filter_scan[mac][beam_ev_counter].recover+=10;
          if((evbuf_filter[mac][i].ts0)<ts1_ref_approved[j][0]){
            evbuf_filter_scan[mac][beam_ev_counter].ts1=4e9+ts1_ref_approved[j][0]-evbuf_filter[mac][i].ts0;}
          else evbuf_filter_scan[mac][beam_ev_counter].ts1=evbuf_filter[mac][i].ts1;
          evbuf_filter_scan[mac][beam_ev_counter].nrtrigger=ts1_ref_counter[mac];
          beam_ev_counter++;
          break;
        }
      }
    }
  }
  if(run_mode_==FILTER_PAIR_MODE) {
    ev_counter_filter_scan[mac]=beam_ev_counter;
	  scan_filter_buffer(mac); 
 }
  
  if(run_mode_==TS1_CORR) { //scan all for pairs, with corrected ts1...
    ev_counter_filter_scan[mac]=ev_counter_filter[mac];
	  scan_filter_buffer(mac); 
  } 
}
//scanned all hits of one module and looks for time coincidences in the second of all other modules/////////////////////////////////////////
void crt::CRTRawInputDetail::scan_filter_buffer(int mac){  //scan over all events of one plane over one sec and search all possible coincidences
  //std::cout<<"scan for pairs data" <<std::endl;
  long time1, time2;
  long delta;
  int counter_mac[MAXFEBNR];
  for (int i=0; i<MAXFEBNR; i++) counter_mac[i]=0;
  for(int i=0;i<ev_counter_filter_scan[mac];i++){
    if(run_mode_!=TS1_CORR || !(i>20 && (evbuf_filter_scan[mac][i].ts0 > (1e9-MSOVERLAP)))){ 
    //printf("jump: %3d: mac: %2d, flags: %2d, ts0: %10d, ts1: %10d, sec: %10d  dt: %d, lostcpu: %d\n", i,evbuf_filter_scan[mac][i].mac5, evbuf_filter_scan[mac][i].flags, evbuf_filter_scan[mac][i].ts0,evbuf_filter_scan[mac][i].ts1,evbuf_filter_scan[mac][i].sec, evbuf_filter_scan[mac][i].ts0-evbuf_filter_scan[mac][i].ts1, evbuf_filter_scan[mac][i].lostcpu ); 
    time1=evbuf_filter_scan[mac][i].ts0;
    for(int j=0;j<MAXFEBNR;j++){
        if(j!=mac && (counter_mac[j]<ev_counter_filter_scan[j])){
          //std::cout<<"mac " << mac << " j= " << j << " counter_mac[j] " << counter_mac[j] << " ev_counter_filter_scan[j] " << ev_counter_filter_scan[j] <<std::endl;
        for(int k=counter_mac[j];k<ev_counter_filter_scan[j];k++){
          if(run_mode_!=TS1_CORR || !(k>20 && (evbuf_filter_scan[j][k].ts0 > (1e9-MSOVERLAP)))){  
           time2=evbuf_filter_scan[j][k].ts0;
           delta=time2-time1;

           if((std::abs(delta)<MAX_TIME_DIFFERENCE)&&((evbuf_filter_scan[j][k].flags==3 && evbuf_filter_scan[mac][i].flags==3)||(evbuf_filter_scan[j][k].flags==1 && evbuf_filter_scan[mac][i].flags==1))){
             coincidence[0].mac5=evbuf_filter_scan[mac][i].mac5;
             coincidence[0].flags=evbuf_filter_scan[mac][i].flags;
             coincidence[0].lostcpu=evbuf_filter_scan[mac][i].lostcpu;
             coincidence[0].lostfpga=evbuf_filter_scan[mac][i].lostfpga;
             coincidence[0].ts0_corr=evbuf_filter_scan[mac][i].ts0_corr;
             coincidence[0].ts0=evbuf_filter_scan[mac][i].ts0_scaled;
             coincidence[0].sec_corr=evbuf_filter_scan[mac][i].sec_corr;
             coincidence[0].sec=evbuf_filter_scan[mac][i].sec;
             coincidence[0].ts1=evbuf_filter_scan[mac][i].ts1;
             for(int amp=0;amp<32;amp++) coincidence[0].adc[amp]=evbuf_filter_scan[mac][i].adc[amp];
             coincidence[0].recover=evbuf_filter_scan[mac][i].recover;
             coincidence[0].nrtrigger=evbuf_filter_scan[mac][i].nrtrigger;
             coincidence[0].nrtrigger_11=evbuf_filter_scan[mac][i].nrtrigger_11;

             coincidence[1].mac5=evbuf_filter_scan[j][k].mac5;
             coincidence[1].flags=evbuf_filter_scan[j][k].flags;
             coincidence[1].lostcpu=evbuf_filter_scan[j][k].lostcpu;
             coincidence[1].lostfpga=evbuf_filter_scan[j][k].lostfpga;
             coincidence[1].ts0_corr=evbuf_filter_scan[j][k].ts0_corr;
             coincidence[1].ts0=evbuf_filter_scan[j][k].ts0_scaled;
             coincidence[1].sec_corr=evbuf_filter_scan[j][k].sec_corr;
             coincidence[1].sec=evbuf_filter_scan[j][k].sec;
             coincidence[1].ts1=evbuf_filter_scan[j][k].ts1;
             for(int amp=0;amp<32;amp++) coincidence[1].adc[amp]=evbuf_filter_scan[j][k].adc[amp];
             coincidence[1].recover=evbuf_filter_scan[j][k].recover;
             coincidence[1].nrtrigger=evbuf_filter_scan[j][k].nrtrigger;
             coincidence[1].nrtrigger_11=evbuf_filter_scan[j][k].nrtrigger_11;

             coincidence[2].mac5=0xFFFF;
             coincidence[2].flags=2;
             coincidence[2].ts0=evbuf_filter_scan[mac][i].sec_corr;
             coincidence[2].ts1=evbuf_filter_scan[j][k].sec;
             for(int amp=0;amp<32;amp++) coincidence[2].adc[amp]=0;
             coincidence[2].adc[0]=(uint16_t)evbuf_filter_scan[mac][i].ms;
             coincidence[2].adc[1]=(uint16_t)evbuf_filter_scan[j][k].ms;
             coincidence[2].recover=std::abs(i-j);
             make2DHit();
             counter_mac[j]=k;
             //std::cout << "couter = "<< k << std::endl;
             break;
           }
         }
       } //std::cout<<"end loop all events" <<std::endl;//end loop through all events of feb j
      }
     }//std::cout<<"end loop all febs" <<std::endl;//end loop over all febs
   }
  }
  //std::cout<<"end scan filter" <<std::endl;
  ready_to_scan=SCANBUF_READY_TO_FILL;
}
//own asolute value function for unsigned ints...///////////////////////////////////////////////////////////////////////////////////////////
unsigned int crt::CRTRawInputDetail::my_abs(unsigned int a, unsigned int b){
  unsigned int c=0;
  if(a<b) c=b-a;
  else c=a-b;
  return c;
}

void crt::CRTRawInputDetail::make2DHit(){
  //std::cout<<"make 2D hit" <<std::endl;
  //if(coincidence[0].lostcpu==99||coincidence[1].lostcpu==99) std::cout << "hits with stucked event!!!!!!!" << std::endl;
  crt::CRTHit crt2Dhit;
  int max1_ach=0, max1_nch=0, max2_ach=0, max2_nch=0;// max1_adc=0,  max2_adc=0;
  
  int ch[16];
  for(int j=0;j<16;j++){ //set max_ach + max__nch
    ch[j]=0;
    ch[j]=coincidence[0].adc[j*2]+coincidence[0].adc[j*2+1];
    if(ch[j]>max1_ach) {max1_ach=ch[j]; max1_nch=j;}
    ch[j]=0;
    ch[j]=coincidence[1].adc[j*2]+coincidence[1].adc[j*2+1];
    if(ch[j]>max2_ach) {max2_ach=ch[j]; max2_nch=j;}
  }
  uint16_t max_temp1_tevt=coincidence[0].adc[max1_nch*2];
  uint16_t max_temp2_tevt=coincidence[0].adc[max1_nch*2+1];
  int key_tevt1 = coincidence[0].mac5*100+max1_nch*2;
  int key_tevt2 = coincidence[0].mac5*100+max1_nch*2+1;

  std::pair<double,double> gain_tevt1 = crt::auxfunctions::getGain(key_tevt1, SiPMgain); 
  std::pair<double,double> pedestal_tevt1 = crt::auxfunctions::getGain(key_tevt1, SiPMpedestal);
  double pesmax_tevt1 = (max_temp1_tevt - pedestal_tevt1.first) / gain_tevt1.first;
  std::vector<double> pos_tevt1 = crt::auxfunctions::getPos(key_tevt1, sensor_pos);

  
  int key_st1 = coincidence[1].mac5*100+2*max2_nch;
  int key_st2 = coincidence[1].mac5*100+2*max2_nch+1;
  uint16_t max_temp1_st=coincidence[1].adc[max2_nch*2];
  uint16_t max_temp2_st=coincidence[1].adc[max2_nch*2+1];

  std::pair<double,double> gain_st1 = crt::auxfunctions::getGain(key_st1, SiPMgain);
  std::pair<double,double> pedestal_st1 = crt::auxfunctions::getGain(key_st1, SiPMpedestal);
  double pesmax_st1 = (max_temp1_st - pedestal_st1.first) / gain_st1.first;                                                                 
  std::vector<double> pos_st1 = crt::auxfunctions::getPos(key_st1, sensor_pos);

  //pos vector/ 0=x 1=y 2=z 3=plane 4=layer 5=orientation;   //clean up!!! after MC
  if( (pos_tevt1[3]==pos_st1[3] ) && (pos_tevt1[4]!=pos_st1[4]) 
		&& ( (std::abs(pos_tevt1[4]-pos_st1[4])<2) || ((pos_tevt1[3]==2) && (pos_tevt1[4]==0 && pos_st1[4]==2)) || ((pos_tevt1[3]==2) && (pos_tevt1[4]==2 && pos_st1[4]==0)) )
    && (pos_tevt1[5]!=pos_st1[5])){
    
    hit_mac_1=coincidence[0].mac5;
    hit_mac_2=coincidence[1].mac5;
    
    std::pair<double,double> gain_tevt2 = crt::auxfunctions::getGain(key_tevt2, SiPMgain);
    std::pair<double,double> pedestal_tevt2 = crt::auxfunctions::getGain(key_tevt2, SiPMpedestal);
    double pesmax_tevt2 = (max_temp2_tevt - pedestal_tevt2.first) / gain_tevt2.first;
    std::vector<double> pos_tevt2 = crt::auxfunctions::getPos(key_tevt2, sensor_pos);
    
    std::pair<double,double> gain_st2 = crt::auxfunctions::getGain(key_st2, SiPMgain);
    std::pair<double,double> pedestal_st2 = crt::auxfunctions::getGain(key_st2, SiPMpedestal);
    double pesmax_st2 = (max_temp2_st - pedestal_st2.first) / gain_st2.first;
    std::vector<double> pos_st2 = crt::auxfunctions::getPos(key_st2, sensor_pos);
    
    
    crt2Dhit.feb_id.push_back(coincidence[0].mac5);
    crt2Dhit.feb_id.push_back(coincidence[1].mac5);
    
    crt2Dhit.plane = pos_tevt1[3]; 

    std::vector<std::pair<int,float> > vec_pes_tevt;
    std::vector<std::pair<int,float> > vec_pes_st;

    for(size_t i_chan=0; i_chan<32; ++i_chan){
      int key_tevt = coincidence[0].mac5*100+i_chan;
      std::pair<double,double> gain_tevt = crt::auxfunctions::getGain(key_tevt, SiPMgain);
      std::pair<double,double> pedestal_tevt = crt::auxfunctions::getGain(key_tevt, SiPMpedestal);
      double pes_tevt = ( (coincidence[0].adc[i_chan]) - pedestal_tevt.first) / gain_tevt.first;
      //double pes_tevt =  (double)coincidence[0].adc[i_chan];
      std::pair<int,float> pair_tevt = std::make_pair(i_chan,pes_tevt);
      vec_pes_tevt.push_back(pair_tevt);

      int key_st = coincidence[1].mac5*100+i_chan;
      std::pair<double,double> gain_st = crt::auxfunctions::getGain(key_st, SiPMgain);
      std::pair<double,double> pedestal_st = crt::auxfunctions::getGain(key_st, SiPMpedestal);
      double pes_st = ( coincidence[1].adc[i_chan] - pedestal_st.first) / gain_st.first;
      //double pes_st =  (double)coincidence[1].adc[i_chan];
      std::pair<int,float> pair_st = std::make_pair(i_chan,pes_st);
      vec_pes_st.push_back(pair_st);
    }
    
    std::map< uint8_t, std::vector<std::pair<int,float> > > pesmap_hit;
    pesmap_hit[coincidence[0].mac5] = vec_pes_tevt;
    pesmap_hit[coincidence[1].mac5] = vec_pes_st;
    crt2Dhit.pesmap = pesmap_hit;

    double LBar = 10.8;
	  if(pos_tevt1[3]==3) LBar = 11.2;//for top	       
    std::vector<double> interpos_tevt = crt::auxfunctions::inter_X(pesmax_tevt1, pos_tevt1, pesmax_tevt2, pos_tevt2, LBar);
    double interpos_tevt_err = crt::auxfunctions::inter_X_error(pesmax_tevt1, pesmax_tevt2, LBar);

	  LBar = 10.8;
    if(pos_st1[3]==3) LBar = 11.2;//for top	  
    std::vector<double> interpos_st = crt::auxfunctions::inter_X(pesmax_st1, pos_st1, pesmax_st2, pos_st2, LBar);
	  double interpos_st_err = crt::auxfunctions::inter_X_error(pesmax_st1, pesmax_st2, LBar);
    double PEStot = pesmax_tevt1 + pesmax_tevt2 + pesmax_st1 + pesmax_st2;   
    
    crt2Dhit.peshit=PEStot;
    pestot=PEStot;
    hPEStot->Fill(PEStot);
    hPES->Fill(pesmax_tevt1);
    hPES->Fill(pesmax_tevt2);
    hPES->Fill(pesmax_st1);
    hPES->Fill(pesmax_st2);

    double FEB_del1 = crt::auxfunctions::getFEBDel(coincidence[0].mac5,FEBDel); //cable_length FEB delay in ns.       
    double FEB_del2 = crt::auxfunctions::getFEBDel(coincidence[1].mac5,FEBDel); //cable_length FEB delay in ns.   
    
    //correct time propagation along the fiber, 6.2 ns/m.  Ttrue = Treg - correction.
    double hit1_time_ns = crt::auxfunctions::getTcorr(interpos_tevt, interpos_st, (coincidence[0].ts0_corr + FEB_del1));
    double hit2_time_ns = crt::auxfunctions::getTcorr(interpos_st, interpos_tevt, (coincidence[1].ts0_corr + FEB_del2));

    td = ((hit1_time_ns) - (hit2_time_ns));//in ns, corrected
    hit_time_ns=(hit1_time_ns+hit2_time_ns)/2;
    hit_time_s=coincidence[0].sec_corr;
    
    double hit1_time_ns_uncorr = crt::auxfunctions::getTcorr(interpos_tevt, interpos_st, (coincidence[0].ts0 + FEB_del1));
    double hit2_time_ns_uncorr = crt::auxfunctions::getTcorr(interpos_st, interpos_tevt, (coincidence[1].ts0 + FEB_del2));
    double hit_time_ns_uncorr=(hit1_time_ns_uncorr+hit2_time_ns_uncorr)/2;
    
    if(my_abs(coincidence[2].adc[0],coincidence[2].adc[1])>800){
      if(my_abs(coincidence[2].adc[0],((uint32_t)hit_time_ns/1e6))<my_abs(coincidence[2].adc[1],((uint32_t)hit_time_ns/1e6))) hit_time_ms=coincidence[2].adc[0];
      else hit_time_ms=coincidence[2].adc[1];
    }
    else hit_time_ms=((double)(coincidence[2].adc[0]+coincidence[2].adc[1]))/2.0;
    //printf("ms1: %d,ms2: %d,diff: %d, hit_ns: %lf, hitms: %lf\n",coincidence[2].adc[0],coincidence[2].adc[1],my_abs(coincidence[2].adc[0],coincidence[2].adc[1]), hit_time_ns/1e6, hit_time_ms);
    beam_trigger=coincidence[0].nrtrigger;
    pps_trigger=coincidence[0].nrtrigger_11;

    if( (interpos_tevt[6]==1) && (interpos_st[6] != 1) ){xtot=interpos_tevt[0];} 
    if( (interpos_tevt[6]==2) && (interpos_st[6] != 2) ){ytot=interpos_tevt[1];}	
    if( (interpos_tevt[6]==3) && (interpos_st[6] != 3) ){ztot=interpos_tevt[2];}


    if( (interpos_st[6]==1) && (interpos_tevt[6] != 1) ){xtot=interpos_st[0];}
    if( (interpos_st[6]==2) && (interpos_tevt[6] != 2) ){ytot=interpos_st[1];}
    if( (interpos_st[6]==3) && (interpos_tevt[6] != 3) ){ztot=interpos_st[2];}


    if( (interpos_st[6] !=1) && (interpos_tevt[6] != 1) ){xtot=(interpos_tevt[0] + interpos_st[0])/2;}     
    if( (interpos_st[6] !=2) && (interpos_tevt[6] != 2) ){ytot=(interpos_tevt[1] + interpos_st[1])/2;}	
    if( (interpos_st[6] !=3) && (interpos_tevt[6] != 3) ){ztot=(interpos_tevt[2] + interpos_st[2])/2;}
    
    /////////////////////////////
    
    int ts1_local1=0, ts1_local2=0;
    if(coincidence[0].ts1>=4e9){ ts1_local1=-(coincidence[0].ts1-4e9);}
    else ts1_local1=coincidence[0].ts1;
    if(coincidence[1].ts1>=4e9){ ts1_local2=-(coincidence[1].ts1-4e9);}
    else ts1_local2=coincidence[1].ts1;
    
    double beam1_time_ns = crt::auxfunctions::getTcorr(interpos_tevt, interpos_st, (ts1_local1 + FEB_del1));
    double beam2_time_ns = crt::auxfunctions::getTcorr(interpos_st, interpos_tevt, (ts1_local2 + FEB_del2));

    beam_time_ns=(beam1_time_ns+beam2_time_ns)/2;
    
    crt2Dhit.ts0_ns=hit_time_ns;
    crt2Dhit.ts0_ns_corr=hit_time_ns - hit_time_ns_uncorr;
    //crt2Dhit.pollms=hit_time_ms;
    //crt2Dhit.ts0_ns_err=std::abs((coincidence[0].ts0+coincidence[0].ts0)/2-crt2Dhit.ts0_ns);
    crt2Dhit.ts1_ns=beam_time_ns;
    //crt2Dhit.ts1_ns_err=std::abs((ts1_local1+ts1_local2)/2-crt2Dhit.ts1_ns);
    
     crt2Dhit.ts0_s=coincidence[0].sec_corr;
     crt2Dhit.ts0_s_corr=(long)coincidence[0].sec_corr-coincidence[0].sec;
    /*
    std::map< uint8_t, uint16_t > lostcpu_map;
    lostcpu_map[coincidence[0].mac5] = coincidence[0].lostcpu;
    lostcpu_map[coincidence[1].mac5] = coincidence[1].lostcpu;
    crt2Dhit.lostcpu_map = lostcpu_map;
    
    std::map< uint8_t, uint16_t > lostfpga_map;
    lostfpga_map[coincidence[0].mac5] = coincidence[0].lostfpga;
    lostfpga_map[coincidence[1].mac5] = coincidence[1].lostfpga;
    crt2Dhit.lostfpga_map = lostfpga_map;
    */
    //crt2Dhit.event_flag=0;
    //crt2Dhit.pollms=(coincidence[2].adc[1]+coincidence[2].adc[0])/2;
    
    crt2Dhit.x_pos= xtot;
    crt2Dhit.x_err=sqrt( pow(interpos_tevt_err,2) + pow(interpos_st_err,2) );
    crt2Dhit.y_pos= ytot;
    crt2Dhit.y_err= sqrt( pow(interpos_tevt_err,2) + pow(interpos_st_err,2) );
    crt2Dhit.z_pos= ztot;
    crt2Dhit.z_err= sqrt( pow(interpos_tevt_err,2) + pow(interpos_st_err,2) );
    
    plane=crt2Dhit.plane;
    pesmap=pesmap_hit;
    
    FEBvsFEB->Fill(coincidence[0].mac5,coincidence[1].mac5);
    TimeDiff->Fill(td);
    BeamTime->Fill(beam_time_ns+fOffset_);
    //quality plots
    hxtot->Fill(xtot);
    hytot->Fill(ytot);
    hztot->Fill(ztot);
    //quality plot
    if(plane==0){HitDistBot->Fill(ztot,xtot);}                                               
    if(plane==1){HitDistFT->Fill(ztot, ytot);}
    if(plane==2){HitDistPipe->Fill(ztot, ytot);}
    if(plane==3){HitDistTop->Fill(ztot,xtot);}        
     my_tree_->Fill();
    //quality plot

		if(verbose_!=0){
			printf("max1_ach: %d, max1_nch %d, max2_ach: %d, max2_nch: %d\n", max1_ach,max1_nch, max2_ach, max2_nch);
			printf("ids: %d, %d, x: %f, y: %f, z: %f, plane: %d\n", crt2Dhit.feb_id[0], crt2Dhit.feb_id[1], crt2Dhit.x_pos, crt2Dhit.y_pos, crt2Dhit.z_pos, crt2Dhit.plane);
			printf("ts0: %d, ts1: %d, sec: %d\n", crt2Dhit.ts0_s, crt2Dhit.ts1_ns, crt2Dhit.ts0_s);
		}
    allmyCRTHits.push_back(crt2Dhit);
    if(allmyCRTHits.size()>2 && save_event!=1) check_storing();
	}
  //std::cout<<"end 2d hit" <<std::endl;
}

void crt::CRTRawInputDetail::check_storing(){
  //std::cout<<"check store data" <<std::endl;
  if((allmyCRTHits[allmyCRTHits.size()-1].ts0_s-allmyCRTHits[0].ts0_s)>2){
    //std::cout<<"radyto send store data" <<std::endl;
    save_event=1;
    uint32_t this_sec=allmyCRTHits[0].ts0_s;
    int hit_counter=0;
    for(unsigned int i=0; i<allmyCRTHits.size(); i++){
      if(allmyCRTHits[i].ts0_s==this_sec){
        allCRTHits.push_back(allmyCRTHits[i]);
        hit_counter++;
      }
    }
    int stop=allmyCRTHits.size();
    for(int i=0; i<stop; i++){
      if(allmyCRTHits[i].ts0_s==this_sec){
        allmyCRTHits.erase (allmyCRTHits.begin()+i);
        i--;
        stop--;
      }  
    }
    total_hits+=hit_counter;
    if(verbose_==1) std::cout<<"found: " << hit_counter << " of " << total_hits << " in the second: "<< this_sec <<std::endl;
  }
  //std::cout<<"end store data" <<std::endl;
}
/*
void crt::CRTRawInputDetail::Init_TS0_corr(std::string filename){
  for(int i=0;i<50;i++){
    correctionpoints[i].sec=0;
    correctionpoints[i].offset=0;
    correctionpoints[i].scale=0;
  }
  
  uint32_t sec;
  double offset;
  double scale;
  int counter=0;
  
  std::ifstream in;
  in.open(filename);
  std::cout << filename<< std::endl;
  if (in.is_open()){
    std::cout << "read data" << std::endl;
    while (!in.eof()) {
      in>>sec>>offset>>scale;
      if(sec>=(start_NTP-3600) && sec<(end_NTP+3600)){
        correctionpoints[counter].sec=sec;
        correctionpoints[counter].offset=offset;
        correctionpoints[counter].scale=scale;
        counter++;
      }
    }      
    in.close();
  }
  for(int i=0; i<counter;i++){
    printf("sec: %d, offset: %lf, scale: %lf\n",correctionpoints[i].sec, correctionpoints[i].offset, correctionpoints[i].scale);
  }
}*/

double crt::CRTRawInputDetail::NTP_deviation(std::string filename){
  int found_diff=0;
  int diff_start[500];
  int diff_middle[500];
  int diff_end[500];
  
  int diff_start2[500];
  int diff_middle2[500];
  int diff_end2[500];
  
  long second_start=0;
  long second_end=0;
  long second_middle=0;
  
  double scale=0;
  
  EVENT_t NTP_diff;
  EOP_EVENT_t NTP_refevent;
  FILE * data=fopen(filename.c_str(),"r");
  
  fseek(data, 0, SEEK_END); // seek to end of file
  long end1=ftell(data)/sizeof(EVENT_t); //store position of the end
  long middle=end1/2; // calculate the position of the middle
  if((end1)>1e6){
    //difference at the beginnig of the run
    fseek(data, 0, SEEK_SET); // seek back to beginning of file
    while(found_diff<500){
      if(fread(&NTP_diff,sizeof(EVENT_t),1,data)<=0) return 0;
      if(NTP_diff.mac5==0xFFFF){
        memcpy(&NTP_refevent,&NTP_diff.mac5,sizeof(EOP_EVENT_t));
        if(fread(&NTP_diff,sizeof(EVENT_t),1,data)<=0) return 0;
        if(second_start==0) second_start=NTP_refevent.start_s;
        //printf("ms: %d, ts0: %d, sec: %d \n",NTP_refevent.start_ms,NTP_diff.ts0,NTP_refevent.start_s);
        diff_start[found_diff]=(int)NTP_refevent.start_ms-NTP_diff.ts0/1e6;
        long position = ftell(data); // get current file pointer
        fseek(data, position-3*sizeof(EVENT_t), SEEK_SET);
        if(fread(&NTP_diff,sizeof(EVENT_t),1,data)<=0) return 0;
        diff_start2[found_diff]=(int)NTP_refevent.end_ms-NTP_diff.ts0/1e6;
        fseek(data, position+6*sizeof(EVENT_t), SEEK_SET);
        found_diff++;
      }  
    }
    //find position of middle and endof the run
    fseek(data, middle*sizeof(EVENT_t), SEEK_SET);// go to the middle of the file
    // difference in the middle of the run
    found_diff=0;
    while(found_diff<500){
      if(fread(&NTP_diff,sizeof(EVENT_t),1,data)<=0) return 0;
      if(NTP_diff.mac5==0xFFFF){
        memcpy(&NTP_refevent,&NTP_diff.mac5,sizeof(EOP_EVENT_t));
        if(fread(&NTP_diff,sizeof(EVENT_t),1,data)<=0)  return 0;
        if(second_middle==0) second_middle=NTP_refevent.start_s;
        //printf("ms: %d, ts0: %d, sec: %d \n",NTP_refevent.start_ms,NTP_diff.ts0,NTP_refevent.start_s);
        diff_middle[found_diff]=NTP_refevent.start_ms-NTP_diff.ts0/1e6;

        long position = ftell(data); // get current file pointer
        fseek(data, position-3*sizeof(EVENT_t), SEEK_SET);
        if(fread(&NTP_diff,sizeof(EVENT_t),1,data)<=0) return 0;
        diff_middle2[found_diff]=(int)NTP_refevent.end_ms-NTP_diff.ts0/1e6;
        fseek(data, position+6*sizeof(EVENT_t), SEEK_SET);
        found_diff++;
      }  
    }
    // difference at the end of the run
    found_diff=0;
    fseek(data, 0, SEEK_END);
    int back_counter=2;
    while(found_diff<500){
      fseek(data,(end1-back_counter)*sizeof(EVENT_t) ,SEEK_SET );
      back_counter++;
      if(fread(&NTP_diff,sizeof(EVENT_t),1,data)<=0) return 0;
      //printf(" %d, %d - ",NTP_diff.mac5,NTP_diff.ts0);
      if(NTP_diff.mac5==0xFFFF){
        memcpy(&NTP_refevent,&NTP_diff.mac5,sizeof(EOP_EVENT_t));
        if(fread(&NTP_diff,sizeof(EVENT_t),1,data)<=0) return 0;
        if(second_end==0) second_end=NTP_refevent.start_s;
        //printf("ms: %d, ts0: %d, sec: %d \n",NTP_refevent.start_ms,NTP_diff.ts0,NTP_refevent.start_s);
        diff_end[found_diff]=NTP_refevent.start_ms-NTP_diff.ts0/1e6;

        long position = ftell(data); // get current file pointer
        fseek(data, position-3*sizeof(EVENT_t), SEEK_SET);
        if(fread(&NTP_diff,sizeof(EVENT_t),1,data)<=0) return 0;
        diff_end2[found_diff]=(int)NTP_refevent.end_ms-NTP_diff.ts0/1e6;
        //fseek(data, position+6*sizeof(EVENT_t), SEEK_SET);
        found_diff++;
      }
    }
    //calculate mean and variance, cutout outlayers
    double diff_mean_start=0;
    double diff_mean_middle=0;
    double diff_mean_end=0;

    double diff_mean_start_2=0;
    double diff_mean_middle_2=0;
    double diff_mean_end_2=0;

    //printf(" start - middle - end \n");
    for(int i=0; i<500; i++){
      //printf(" %d - %d - %d \n", diff_start[i], diff_middle[i],diff_end[i]);
      diff_mean_start+=diff_start[i];
      diff_mean_middle+=diff_middle[i];
      diff_mean_end+=diff_end[i];
      diff_mean_start_2+=diff_start2[i];
      diff_mean_middle_2+=diff_middle2[i];
      diff_mean_end_2+=diff_end2[i];
    }
    diff_mean_start/=500.0;
    diff_mean_middle/=500.0;
    diff_mean_end/=500.0;

    double var_start=0;
    double var_middle=0;
    double var_end=0;

    diff_mean_start_2/=500.0;
    diff_mean_middle_2/=500.0;
    diff_mean_end_2/=500.0;

    double var_start2=0;
    double var_middle2=0;
    double var_end2=0;

    for(int i=0; i<500; i++){
      //printf(" %d - %d - %d \n", diff_start[i], diff_middle[i],diff_end[i]);
      var_start+=(diff_start[i]-diff_mean_start)*(diff_start[i]-diff_mean_start);
      var_middle+=(diff_middle[i]-diff_mean_middle)*(diff_middle[i]-diff_mean_middle);
      var_end+=(diff_end[i]-diff_mean_end)*(diff_end[i]-diff_mean_end);  

      var_start2+=(diff_start2[i]-diff_mean_start_2)*(diff_start2[i]-diff_mean_start_2);
      var_middle2+=(diff_middle2[i]-diff_mean_middle_2)*(diff_middle2[i]-diff_mean_middle_2);
      var_end2+=(diff_end2[i]-diff_mean_end_2)*(diff_end2[i]-diff_mean_end_2);  
    }
    var_start=var_start/(500.0-1.0);
    var_middle=var_middle/(500.0-1.0);
    var_end=var_end/(500.0-1.0);
    var_start=sqrt(var_start);
    var_middle=sqrt(var_middle);
    var_end=sqrt(var_end);

    var_start2=var_start2/(500.0-1.0);
    var_middle2=var_middle2/(500.0-1.0);
    var_end2=var_end2/(500.0-1.0);
    var_start2=sqrt(var_start2);
    var_middle2=sqrt(var_middle2);
    var_end2=sqrt(var_end2);

    //cut out outlayers
    double diff_mean_start2=0;
    double diff_mean_middle2=0;
    double diff_mean_end2=0;

    double diff_mean_start_02=0;
    double diff_mean_middle_02=0;
    double diff_mean_end_02=0;

    int mean_count_start=0, mean_count_middle=0, mean_count_end=0;
    int mean_count_start2=0, mean_count_middle2=0, mean_count_end2=0;
    for(int i=0; i<500; i++){
      //printf(" %d - %d - %d \n", diff_start[i], diff_middle[i],diff_end[i]);
      if(abs(diff_start[i]-diff_mean_start)<var_start){
        diff_mean_start2+=diff_start[i];
        mean_count_start++;
      }
      if(abs(diff_middle[i]-diff_mean_middle)<var_middle){
        diff_mean_middle2+=diff_middle[i];
        mean_count_middle++;
      }
      if(abs(diff_end[i]-diff_mean_end)<var_end){
        diff_mean_end2+=diff_end[i];
        mean_count_end++;
      }

      if(abs(diff_start2[i]-diff_mean_start_2)<var_start2){
        diff_mean_start_02+=diff_start2[i];
        mean_count_start2++;
      }
      if(abs(diff_middle2[i]-diff_mean_middle_2)<var_middle2){
        diff_mean_middle_02+=diff_middle2[i];
        mean_count_middle2++;
      }
      if(abs(diff_end2[i]-diff_mean_end_2)<var_end2){
        diff_mean_end_02+=diff_end2[i];
        mean_count_end2++;
      }
    }
    diff_mean_start2=diff_mean_start2/mean_count_start;
    diff_mean_middle2=diff_mean_middle2/mean_count_middle;
    diff_mean_end2=diff_mean_end2/mean_count_end;

    diff_mean_start_02=diff_mean_start_02/mean_count_start2;
    diff_mean_middle_02=diff_mean_middle_02/mean_count_middle2;
    diff_mean_end_02=diff_mean_end_02/mean_count_end2;

    //printf(" %lf - %lf - %lf \n", var_start, var_middle, var_end);
    //printf(" %lf - %lf - %lf \n", diff_mean_start2, diff_mean_middle2, diff_mean_end2);

    if( diff_mean_end2<(diff_mean_middle2-80) && diff_mean_middle2>(diff_mean_start2+80)) diff_mean_end2+=1e3;
    if( diff_mean_end_02<(diff_mean_middle_02-80) && diff_mean_middle_02>(diff_mean_start_02+80)) diff_mean_end_02+=1e3;

    printf("NTP offset; beginning: %lf - middle: %lf - end: %lf \n", diff_mean_start2, diff_mean_middle2, diff_mean_end2);
    //printf("NTP offset 2; beginning: %lf - middle: %lf - end: %lf \n", diff_mean_start_02, diff_mean_middle_02, diff_mean_end_02);
    printf("Offset, CRT_only: %lf to %lf\n", crt::auxfunctions::CRT_Only_Offset(second_start),crt::auxfunctions::CRT_Only_Offset(second_end));
    //printf(" %lf - %lf - %lf \n", var_start, var_middle, var_end);
  
    scale = (diff_mean_end2 - diff_mean_start2)/(second_end-second_start);
    printf("leads to scaling: %lf ms/s, from %ld to %ld \n", scale, second_start,second_end);
  }
  else{
    fseek(data, 0, SEEK_SET); // seek back to beginning of file
    while(second_start==0){
      if(fread(&NTP_diff,sizeof(EVENT_t),1,data)<=0) return 0;
      if(NTP_diff.mac5==0xFFFF){
        memcpy(&NTP_refevent,&NTP_diff.mac5,sizeof(EOP_EVENT_t));
        second_start=NTP_refevent.start_s;
      }  
    }
    fseek(data, 0, SEEK_END);
    int back_counter=1;
    while(second_end==0){
      fseek(data,(end1-back_counter)*sizeof(EVENT_t) ,SEEK_SET );
      back_counter++;
      if(fread(&NTP_diff,sizeof(EVENT_t),1,data)<=0) return 0;
      if(NTP_diff.mac5==0xFFFF){
        memcpy(&NTP_refevent,&NTP_diff.mac5,sizeof(EOP_EVENT_t));
        second_end=NTP_refevent.start_s;
      }
    }
    printf("No scaling: %lf ms/s, from %ld to %ld \n", scale, second_start,second_end);
    printf("to less events in raw file for NTP correction\n");
  }
  //double scale2 = (diff_mean_end_02 - diff_mean_start_02)/(second_end-second_start);
  //printf("leads to scaling2: %lf ms/s, from %ld to %ld \n", scale2, second_start,second_end);
  
  start_NTP=second_start;
  end_NTP=second_end;
  return scale;
  //printf("tot events: %d, tot events in polls: %d, tot polls: %d\n", end1, tot_ev, tot_poll_ev);
  //printf("\n");
  
}
/*
void crt::CRTRawInputDetail::Init_mspoll_delay(void){
    std::ifstream in;
  in.open(FEB_MS_delay_);
  if (in.is_open()){
    std::cout << "initializing poll ms delay" << std::endl;
    int febnr;
    double factor;
    while (!in.eof()) {
      in>>febnr>>factor;
      Ms_poll[febnr]=factor;
      //std::cout << "FEB: " << febnr << " with factor: " << factor << std::endl;
    }      
    in.close();
    }
   else
   {
    std::cout << "Error opening poll ms delay file";
   }
}

*/
namespace crt {
  using CRTRawInputSource = art::Source<CRTRawInputDetail>;
}

// Define the input source to the art system.
DEFINE_ART_INPUT_SOURCE(crt::CRTRawInputSource)
