////////////////////////////////////////////////////////////////////////
// Class:       TimeExtraction
// Module Type: analyzer
// File:        TimeExtraction_module.cc
// Description: Module for extracting TPC/CRT events GPS timestamp.
// Generated at Fri Jun 23 02:48:04 2017 by David Lorca Galindo using artmod
// from cetpkgsupport v1_11_00.
////////////////////////////////////////////////////////////////////////

#include "art/Framework/Core/EDAnalyzer.h"
#include "art/Framework/Core/ModuleMacros.h"
#include "art/Framework/Principal/Event.h"
#include "art/Framework/Principal/Handle.h"
#include "art/Framework/Principal/Run.h"
#include "art/Framework/Principal/SubRun.h"
#include "canvas/Utilities/InputTag.h"
#include "fhiclcpp/ParameterSet.h"
#include "messagefacility/MessageLogger/MessageLogger.h"

//#include "bernfebdaq-core/Overlays/BernZMQFragment.hh"
#include "artdaq-core/Data/Fragments.hh"

#include "art/Framework/Services/Optional/TFileService.h"

#include "uboone/CRT/CRTProducts/CRTHit.hh"
#include "uboone/CRT/CRTProducts/CRTTrack.hh"
#include "uboone/CRT/CRTAuxFunctions.hh"

#include "TTree.h"

#include "TH1F.h"
#include "TH2F.h"
#include "TH3S.h"
#include "TProfile.h"
#include "TF1.h"
#include "TDatime.h"
#include <iostream>
#include <stdio.h>
#include <sstream>
#include <vector>
#include <map>
#include <utility>

namespace crt {
  class TimeExtraction;
}

class crt::TimeExtraction : public art::EDAnalyzer {
public:
  explicit TimeExtraction(fhicl::ParameterSet const & p);
  // The destructor generated by the compiler is fine for classes
  // without bare pointers or other resource use.

  // Plugins should not be copied or assigned.
  TimeExtraction(TimeExtraction const &) = delete;
  TimeExtraction(TimeExtraction &&) = delete;
  TimeExtraction & operator = (TimeExtraction const &) = delete;
  TimeExtraction & operator = (TimeExtraction &&) = delete;

  // Required functions.
  void analyze(art::Event const & e) override;

  // Selected optional functions.
  void beginJob() override;
  void endJob() override;

private:

  // Declare member data here.

  int fEvtNum; //Number of current event
  uint32_t frunNum;                //Run Number taken from event
  uint32_t fsubRunNum;             //Subrun Number taken from event

  std::string  raw_data_label_;
  int file_type_;
};


crt::TimeExtraction::TimeExtraction(fhicl::ParameterSet const & p)
  : EDAnalyzer(p),
    raw_data_label_(p.get<std::string>("raw_data_label")),
    file_type_(p.get<int>("file_type"))
{}

void crt::TimeExtraction::analyze(art::Event const & evt)
{

  //for TPC
  //if(file_type_==0){
    frunNum    = evt.run();
    fsubRunNum = evt.subRun();
    fEvtNum = evt.event();
    
    art::Timestamp evtTime = evt.time();
    
    auto evt_time_sec = evtTime.timeHigh();  
    auto evt_time_nsec = evtTime.timeLow();  
    std::cout.precision(19);
    
    std::cout<< "Run:  "<<frunNum << "   subRun: " <<fsubRunNum<<std::endl;                          
    std::cout<<"event: "<<fEvtNum <<std::endl;                          
    std::cout<<"Timestamp_sec: (Trigger)  "<<evt_time_sec<< "   " <<std::endl;                          
    std::cout<<"Timestamp_nsec: (Trigger)  "<<evt_time_nsec<< "   " <<std::endl;                          
    std::cout<<"                 " <<std::endl;                          
    
    // }
  //for TPC
     
    



  
  //for crt
  //if(file_type_==1){ 
    art::Handle< std::vector<artdaq::Fragment> > rawHandle;
    //  evt.getByLabel(raw_data_label_, "BernZMQ", rawHandle); //artdaq //daq  
    evt.getByLabel(raw_data_label_, rawHandle); //Converted files //crtdaq                                                                                 

    //check to make sure the data we asked for is valid                                                                                  
    if(!rawHandle.isValid()){
      std::cout << "Run " << evt.run() << ", subrun " << evt.subRun()
		<< ", event " << evt.event() << " has zero"
		<< " BernFEB fragments " << " in module " << raw_data_label_ << std::endl;
      std::cout << std::endl;
      return;
    }
    
    int counter = 1;
    //get better access to the data                                                                                                                             
    std::vector<artdaq::Fragment> const& rawFragments(*rawHandle);
    std::cout<<"                 " <<std::endl;
    std::cout<< "This event contains:  "<<rawFragments.size()<<" artdaq::Fragments"<<std::endl;       
    std::cout<<"                 " <<std::endl;
    //loop over the raw data fragments                                                                                                                          
    //There should be one fragment per FEB in each event.                                                                                                    
    for(auto const& frag : rawFragments){//A                                                                                                  
      
      //overlay this so it's in the "BernFragment" format. Same data!                                                                                          
      bernfebdaq::BernZMQFragment bfrag(frag);
      //Grab the metadata.                                                                                                                                  
      //See bernfebdaq-core/bernfebdaq-core/Overlays/BernFEBFragment.hh                                                                                              
      auto bfrag_metadata = bfrag.metadata();
      size_t   nevents    = bfrag_metadata->n_events();   //number of BernFEBEvents in this packet                                                       
      auto time_start_seconds = bfrag_metadata->time_start_seconds();     //last second.           
      auto time_end_seconds = bfrag_metadata->time_end_seconds();     //last second.                                                                             
      auto time_start_ns = bfrag_metadata->time_start_nanosec();     //from last second.       
      auto time_end_ns = bfrag_metadata->time_end_nanosec();     //last second + 1s.                                                                              
      auto FEB_MAC =  bfrag_metadata->feb_id();     //mac addresss of this packet                  
      
      std::cout<< "Fragment: "<<counter<<std::endl;
      counter++;
      std::cout<< "FEB: "<<FEB_MAC << " :Fragment contains: " <<nevents<<" events"<<std::endl;       
      std::cout<< "time_start_seconds:  "<<time_start_seconds<<std::endl;       
      std::cout<< "time_end_seconds:  "<<time_end_seconds<<std::endl;       
      std::cout<< "time_start_ns:  "<<time_start_ns<<std::endl;       
      std::cout<< "time_end_ns:  "<<time_end_ns<<std::endl;       
      std::cout<<"                 " <<std::endl;                          

      /*          
	if(FEB_MAC==108){//C
	
	  //read event.
	  for(size_t i_e=0; i_e<nevents; ++i_e){//B_1                                                                                    
	    
	    bernfebdaq::BernZMQEvent const* this_event = bfrag.eventdata(i_e); //get the single hit/event                                              
	    
	    //bool sptevent0 = this_event->IsReference_TS0();
	    //bool sptevent1 = this_event->IsReference_TS1();
	    //if( (!sptevent0) && (!sptevent1)  ){//B_2               
	    
	    auto time_ts0 = this_event->Time_TS0();         //grab the event time from last second         
	    auto time_ts1 = this_event->Time_TS1();         //grab the event time from last second         
	    std::cout<<"event: "<<i_e<<std::endl;
	    getchar();
	    for(size_t i_chan=0; i_chan<2; ++i_chan){ //1st max                                                                                                   
	      int adc = this_event->adc[i_chan];
	      std::cout<<"FEB: "<<FEB_MAC<<" SiPM: "<<i_chan<<"  adc: "<< adc<< "  time0: "<<time_ts0<< "  time1: "<<time_ts1 <<std::endl;                          
	    }
	    
	  }//B_1
	  getchar();
	}//C
      	//read event
	*/
    }//A
    
    // }
  //for crt
}

void crt::TimeExtraction::beginJob()
{
  // Implementation of optional member function here.
}

void crt::TimeExtraction::endJob()
{
  // Implementation of optional member function here.
}

DEFINE_ART_MODULE(crt::TimeExtraction)
