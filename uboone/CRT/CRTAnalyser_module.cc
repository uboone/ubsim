////////////////////////////////////////////////////////////////////////
// Class:       CRTAnalyser
// Module Type: analyzer
// File:        CRTAnalyser_module.cc
//
// Generated at Thu Dec  7 06:25:07 2017 by Thomas Mettler using artmod
// from cetpkgsupport v1_13_00.
////////////////////////////////////////////////////////////////////////

#include "art/Framework/Core/EDAnalyzer.h"
#include "art/Framework/Core/ModuleMacros.h"
#include "art/Framework/Principal/Event.h"
#include "art/Framework/Principal/Handle.h"
#include "art/Framework/Principal/Run.h"
#include "art/Framework/Principal/SubRun.h"
//#include "art/Utilities/InputTag.h"
#include "fhiclcpp/ParameterSet.h"
#include "messagefacility/MessageLogger/MessageLogger.h"

#include "art/Framework/Services/Optional/TFileService.h"

//#include "bernfebdaq-core/Overlays/BernZMQFragment.hh"
//#include "artdaq-core/Data/Fragments.hh"

#include "uboone/CRT/CRTProducts/CRTHit.hh"
#include "uboone/CRT/CRTProducts/CRTTrack.hh"
#include "uboone/CRT/CRTAuxFunctions.hh"

#include "TTree.h"

#include "TH1F.h"
#include "TH2F.h"
#include "TH3S.h"
#include "TProfile.h"
#include "TF1.h"
#include "TDatime.h"
#include <iostream>
#include <stdio.h>
#include <sstream>
#include <vector>
#include <map>
#include <utility>
#include <cmath> 
#include <memory>


namespace crt {
  class CRTAnalyser;
}

class crt::CRTAnalyser : public art::EDAnalyzer {
public:
  explicit CRTAnalyser(fhicl::ParameterSet const & p);
  // The destructor generated by the compiler is fine for classes
  // without bare pointers or other resource use.

  // Plugins should not be copied or assigned.
  CRTAnalyser(CRTAnalyser const &) = delete;
  CRTAnalyser(CRTAnalyser &&) = delete;
  CRTAnalyser & operator = (CRTAnalyser const &) = delete;
  CRTAnalyser & operator = (CRTAnalyser &&) = delete;

  // Required functions.
  void analyze(art::Event const & e) override;

  // Selected optional functions.
  void beginJob() override;
  void endJob() override;
  
  void initialize_hits();
  void initialize_tracks();


private:

  // Declare member data here.
  art::ServiceHandle<art::TFileService> tfs;
  
  int verbose_;
  //int numberOfevents_;
  std::string data_label_hits_;
  std::string data_label_tracks_;
  
  //quallity plots for hits//////////////////////
  TH2F* HitDistBot;
  TH2F* HitDistFT;
  TH2F* HitDistPipe;
  TH2F* HitDistTop;

  TH1F* hxtot;
  TH1F* hytot;
  TH1F* hztot;

  TH1F* BeamTime;
  TH2F* FEBvsFEB;

  TH1F* hPEShit;
  //tree variables for hits///////////////////
  TTree*       my_hits_;
  double xtot=-10000., ytot=-10000., ztot=-10000.;
  double xerr=-10000., yerr=-10000., zerr=-10000.;
  double hit_time_ns = -1e18;
  double hit_time_ns_err = -1e18;
  double hit_time_s = -1e18;
  double hit_time_s_err = -1e18;
  double beam_time_ns = -1e18;
  double beam_time_ns_err = -1e18;
  int plane = -1;
  std::vector<uint8_t> feb_id;
  double peshit = -1e19;
  int feb_id1=0;
  int feb_id2=0;
  uint16_t event_flag;
  uint16_t lostcpu1;
  uint16_t lostcpu2;
  uint16_t lostfpga1;
  uint16_t lostfpga2;
  
  
  //quallity plots for tracks//////////////////////
  TH2F* hplavspla;
  TH1F* hTlength;
  TH1F* hTtime;
  TH2F* hTlengthvsTime;
  TH2F* hTlengthvsTimeAbs;
  TProfile* hTlengthvsTimeAbs_prof;
  TH1F* htheta;
  TH1F* hphi;
  TH1F* hts0_ns;
  TH2F* hTvsH;

  TH2F* TrackDistBot;
  TH2F* TrackDistFT;
  TH2F* TrackDistPipe;
  TH2F* TrackDistTop;
  
  //tree variables for tracks///////////////////
  TTree* my_tracks_;
  int feb_id01=0;
  int feb_id02=0;
  int feb_id03=0;
  int feb_id04=0;
  double track_time_ns = -1e18;
  double track_time_1ns = -1e18;
  double track_time_1ns_err = -1e18;
  double track_time_2ns = -1e18;
  double track_time_2ns_err = -1e18;
  double track_time_s = -1e18;
  double track_time_ns_err = -1e18;
  double track_time_s_err = -1e18;
  double track_beam_ns = -1e18;
  double track_beam_ns_err = -1e18;
  double time_diff = 1e24;
  double length = -1e18;
  double theta = -1e18;
  double phi = -1e18;
  double x1 = -1e18;
  double y1 = -1e18;
  double z1 = -1e18;
  double x2 = -1e18;
  double y2 = -1e18;
  double z2 = -1e18;
  double x1_err = -1e18;
  double y1_err = -1e18;
  double z1_err = -1e18;
  double x2_err = -1e18;
  double y2_err = -1e18;
  double z2_err = -1e18;
  double pestrack;
  int plane1=-1;
  int plane2=-1;
  

};


crt::CRTAnalyser::CRTAnalyser(fhicl::ParameterSet const & p)
  :
  EDAnalyzer(p)  // ,
 // More initializers here.
{
  verbose_ = p.get<int>("verbose");
  //numberOfevents_ = p.get<int>("Number_of_Events");
  data_label_hits_ = p.get<std::string>("data_label_hits");
  data_label_tracks_ = p.get<std::string>("data_label_tracks");

}

void crt::CRTAnalyser::analyze(art::Event const & evt)
{
  // Implementation of required member function here.
  //analyse hits///////////////////////////////////////////////////////////////////////////////////
  art::Handle< std::vector<crt::CRTHit> > rawHandle_hits;
  evt.getByLabel(data_label_hits_, rawHandle_hits); //what is the product instance name? no BernZMQ
  int hits_valid=1;
  //check to make sure the data we asked for is valid                                                                                                      
  if(!rawHandle_hits.isValid()){
    std::cout << "Run " << evt.run() << ", subrun " << evt.subRun()
              << ", event " << evt.event() << " has " << "\033[31m" << "zero" << "\033[0m"
              << " CRTHits " << " in module " << data_label_hits_ << std::endl;
    std::cout << std::endl;
    hits_valid=0;
    //return;
  }
  if(hits_valid!=0){
    //get better access to the data               
    std::vector<crt::CRTHit> const& CRTHitCollection(*rawHandle_hits);
    if(rawHandle_hits.isValid()){
      std::cout << "Run " << evt.run() << ", subrun " << evt.subRun()
                << ", event " << evt.event() << " has " << "\033[32m" << CRTHitCollection.size() << "\033[0m"
                << " CRTHits " << " in module " << data_label_hits_ << std::endl;
     // std::cout << std::endl;
     //return;
    }
    for(std::vector<int>::size_type i = 0; i != CRTHitCollection.size(); i++) {//A 

      feb_id1=CRTHitCollection[i].feb_id[0];
      feb_id2=CRTHitCollection[i].feb_id[1];
      
      //event_flag=CRTHitCollection[i].event_flag;
      
      //lostcpu1=CRTHitCollection[i].lostcpu_map.find(CRTHitCollection[i].feb_id[0])->second;
      //lostcpu2=CRTHitCollection[i].lostcpu_map.find(CRTHitCollection[i].feb_id[1])->second;
      //lostfpga1=CRTHitCollection[i].lostfpga_map.find(CRTHitCollection[i].feb_id[0])->second;
      //lostfpga2=CRTHitCollection[i].lostfpga_map.find(CRTHitCollection[i].feb_id[1])->second;

      hit_time_s = CRTHitCollection[i].ts0_s;	
      //hit_time_s_err = CRTHitCollection[i].ts0_s_err;

      hit_time_ns = CRTHitCollection[i].ts0_ns;
      //hit_time_ns_err = CRTHitCollection[i].ts0_ns_err;

      beam_time_ns = CRTHitCollection[i].ts1_ns;
      //beam_time_ns_err = CRTHitCollection[i].ts1_ns_err;

      plane = CRTHitCollection[i].plane;
      peshit = CRTHitCollection[i].peshit;

      xtot = CRTHitCollection[i].x_pos;
      xerr = CRTHitCollection[i].x_err;
      ytot = CRTHitCollection[i].y_pos;
      yerr = CRTHitCollection[i].y_err;
      ztot = CRTHitCollection[i].z_pos;
      zerr = CRTHitCollection[i].z_err;

      my_hits_->Fill();

      hPEShit->Fill(peshit);
      FEBvsFEB->Fill(feb_id1,feb_id2);
      BeamTime->Fill(beam_time_ns);
      hxtot->Fill(xtot);
      hytot->Fill(ytot);
      hztot->Fill(ztot);
      if(plane==0){HitDistBot->Fill(ztot,xtot);}                                               
      if(plane==1){HitDistFT->Fill(ztot, ytot);}
      if(plane==2){HitDistPipe->Fill(ztot, ytot);}
      if(plane==3){HitDistTop->Fill(ztot,xtot);}       
    }//A
  }
  
  // analyse tracks /////////////////////////////////////////////////////////////////////////////// std::cout << "\033[1;31mbold red text\033[0m\n" << std::endl;
  art::Handle< std::vector<crt::CRTTrack> > rawHandle_tracks;
  evt.getByLabel(data_label_tracks_, rawHandle_tracks); //what is the product instance name? no BernZMQ
  int tracks_valid=1;
  //check to make sure the data we asked for is valid                                                                                                      
  if(!rawHandle_tracks.isValid()){
    std::cout << "Run " << evt.run() << ", subrun " << evt.subRun()
              << ", event " << evt.event() << " has " << "\033[31m" << "zero" << "\033[0m"
              << " CRTTracks " << " in module " << data_label_tracks_ << std::endl;
    std::cout << std::endl;
    tracks_valid=0;
    //return;
  }
  //get better access to the data   
  if(tracks_valid!=0){
    std::vector<crt::CRTTrack> const& CRTTrackCollection(*rawHandle_tracks);
    if(rawHandle_tracks.isValid()){
      std::cout << "Run " << evt.run() << ", subrun " << evt.subRun()
                << ", event " << evt.event() << " has " << "\033[32m" << CRTTrackCollection.size() << "\033[0m"
                << " CRTTracks " << " in module " << data_label_tracks_ << std::endl;
      //std::cout << std::endl;
      //return;
    }
    for(std::vector<int>::size_type i = 0; i != CRTTrackCollection.size(); i++) {//A 
      feb_id01 = CRTTrackCollection[i].feb_id[0];
      feb_id02 = CRTTrackCollection[i].feb_id[1];
      feb_id03 = CRTTrackCollection[i].feb_id[2];
      feb_id04 = CRTTrackCollection[i].feb_id[3];

      track_time_ns = CRTTrackCollection[i].ts0_ns;
      track_time_s = CRTTrackCollection[i].ts0_s;
      track_time_ns_err = CRTTrackCollection[i].ts0_ns_err;
      track_time_s_err = CRTTrackCollection[i].ts0_s_err;
      track_beam_ns = CRTTrackCollection[i].ts1_ns;
      track_beam_ns_err = CRTTrackCollection[i].ts1_ns_err;
      time_diff = CRTTrackCollection[i].ts0_ns_h1 - CRTTrackCollection[i].ts0_ns_h2;
      track_time_1ns =  CRTTrackCollection[i].ts0_ns_h1;
      track_time_1ns_err =  CRTTrackCollection[i].ts0_ns_err_h1;
      track_time_2ns =  CRTTrackCollection[i].ts0_ns_h2;
      track_time_2ns_err =  CRTTrackCollection[i].ts0_ns_err_h2;

      length = CRTTrackCollection[i].length;
      theta = CRTTrackCollection[i].thetaxy;
      phi = CRTTrackCollection[i].phizy;
      x1 = CRTTrackCollection[i].x1_pos;
      x1_err = CRTTrackCollection[i].x1_err;;
      x2 = CRTTrackCollection[i].x2_pos;
      x2_err = CRTTrackCollection[i].x2_err;
      y1 = CRTTrackCollection[i].y1_pos;
      y1_err = CRTTrackCollection[i].y1_err;
      y2 = CRTTrackCollection[i].y2_pos;
      y2_err = CRTTrackCollection[i].y2_err;
      z1 = CRTTrackCollection[i].z1_pos;
      z1_err = CRTTrackCollection[i].z1_err;
      z2 = CRTTrackCollection[i].z2_pos;
      z2_err = CRTTrackCollection[i].z2_err;
      if(y1<-240) plane1=0;
      else if(y1>600) plane1=3;
      else if(x1<0) plane1=1;
      else if(x1>0) plane1=2;
      if(y2<-240) plane2=0;
      else if(y2>600) plane2=3;
      else if(x2<0) plane2=1;
      else if(x2>0) plane2=2;

      hplavspla->Fill(plane1,plane2);	
      hTlength->Fill(length);
      hTtime->Fill(std::abs(time_diff));
      hTlengthvsTimeAbs->Fill(length,std::abs(time_diff));
      hTlengthvsTimeAbs_prof->Fill(length,std::abs(time_diff));
      hTlengthvsTime->Fill(length,time_diff);
      htheta->Fill(theta);
      hphi->Fill(phi);
      hts0_ns->Fill(track_time_ns);

      if(plane1==0){
        TrackDistBot->Fill(z1,x1);
      }
      if(plane1==1){
        TrackDistFT->Fill(z1, y1);
      }
      if(plane1==2){
        TrackDistPipe->Fill(z1, y1);
      }
      if(plane1==3){
        TrackDistTop->Fill(z1,x1);
      }
      if(plane2==0){
        TrackDistBot->Fill(z2,x2);
      }
      if(plane2==1){
        TrackDistFT->Fill(z2, y2);
      }
      if(plane2==2){
        TrackDistPipe->Fill(z2, y2);
      }
      if(plane2==3){
        TrackDistTop->Fill(z2,x2);
      }
      //plane1;
      //plane2;
      pestrack = CRTTrackCollection[i].peshit;

      my_tracks_->Fill();

    }
  }
  
}

void crt::CRTAnalyser::initialize_hits()
{
  // Implementation of required member function here.
  std::cout << "Initialize variables and histograms for hits" << std::endl;
  //tree stuff for hits: //////////////////////////////////////////////////////////////////////////////////
  my_hits_ = tfs->make<TTree>("my_hits","CRT hit Tree");
  my_hits_->Branch("feb_id1",&feb_id1,"FEB Nr 1/I");
  my_hits_->Branch("feb_id2",&feb_id2,"FEB Nr 2/I");
  my_hits_->Branch("hit_time_s", &hit_time_s, "time (s)/D");
  my_hits_->Branch("hit_time_s_err", &hit_time_s_err, "time error (s)/D");
  my_hits_->Branch("hit_time_ns", &hit_time_ns, "time (ns)/D");
  my_hits_->Branch("hit_time_ns_err", &hit_time_ns_err, "time error (ns)/D");
  my_hits_->Branch("beam_time_ns", &beam_time_ns, "beam time (ns)/D");
  my_hits_->Branch("beam_time_ns_err", &beam_time_ns_err, "beam time error (ns)/D");
  my_hits_->Branch("CRTplane", &plane, "(0=Bot, 1=FT, 2=PS, 3=Top)/i");
  my_hits_->Branch("peshit", &peshit, "peshit/D");
  my_hits_->Branch("Xreco", &xtot, "Xreco (cm)/D");
  my_hits_->Branch("Yreco", &ytot, "Yreco (cm)/D");
  my_hits_->Branch("Zreco", &ztot, "Zreco (cm)/D");
  my_hits_->Branch("Xerr", &xerr, "Xerr (cm)/D");
  my_hits_->Branch("Yerr", &yerr, "Yerr (cm)/D");
  my_hits_->Branch("Zerr", &zerr, "Zerr (cm)/D");
  
  my_hits_->Branch("event_flag",&event_flag,"event_flag 1/I");
  my_hits_->Branch("lostcpu1",&lostcpu1,"lostcpu1/I");
  my_hits_->Branch("lostcpu2",&lostcpu2,"lostcpu2/I");
  my_hits_->Branch("lostfpga1",&lostfpga1,"lostfpga1/I");
  my_hits_->Branch("lostfpga2",&lostfpga2,"lostfpga2/I");
  //quality plots for hits:  /////////////////////////////////////////////////////////////////////////////////
   double inch =2.54; //inch in cm 
  HitDistBot = tfs->make<TH2F>("hBottom","Bottom",125,-700+205*inch,-700+205*inch+125*10.89,60,-300+50.4*inch,-300+50.4*inch+60*10.89);
  HitDistBot->GetXaxis()->SetTitle("Lenght along the beam (cm)");
  HitDistBot->GetYaxis()->SetTitle("Lenght along the drift (cm)");
  HitDistBot->GetZaxis()->SetTitle("Entries/bin");
  HitDistBot->SetOption("COLZ");

  HitDistFT = tfs->make<TH2F>("hFeedthroughSide","Feedthrough Side",125,-704+205*inch,-704+205*inch+125*10.89,60,-308-19.1*inch,-308-19.1*inch+60*10.89);
  HitDistFT->GetXaxis()->SetTitle("Lenght along the beam (cm)");
  HitDistFT->GetYaxis()->SetTitle("Height (cm)");
  HitDistFT->GetZaxis()->SetTitle("Entries/bin");
  HitDistFT->SetOption("COLZ");

  HitDistPipe = tfs->make<TH2F>("hPipeSide","Pipe Side",125,-704+205*inch,-704+205*inch+125*10.89,60,-294-19.1*inch,-294-19.1*inch+60*10.89);
  HitDistPipe->GetXaxis()->SetTitle("Lenght along the beam (cm)");
  HitDistPipe->GetYaxis()->SetTitle("Height (cm)");
  HitDistPipe->GetZaxis()->SetTitle("Entries/bin");
  HitDistPipe->SetOption("COLZ");

  HitDistTop = tfs->make<TH2F>("hTop","Top",125,-701+205*inch,-701+205*inch+125*11.38,80,2-170-300+50.4*inch,2-170-300+50.4*inch+80*11.38);
  HitDistTop->GetXaxis()->SetTitle("Lenght along the beam (cm)");
  HitDistTop->GetYaxis()->SetTitle("Lenght along the drift (cm)"); 
  HitDistTop->GetZaxis()->SetTitle("Entries/bin"); 
  HitDistTop->SetOption("COLZ");
  
  FEBvsFEB = tfs->make<TH2F>("hFEBvsFEB","FEBvsFEB",130,0,130,130,0,130);
  FEBvsFEB->GetXaxis()->SetTitle("FEB ID");
  FEBvsFEB->GetYaxis()->SetTitle("FEB ID");
  FEBvsFEB->SetOption("COLZ");
  
  BeamTime = tfs->make<TH1F>("hBeamEvents","ts1 + offset",250,0,25000);
  BeamTime->GetXaxis()->SetTitle("Time after Beam (ns)");
  BeamTime->GetYaxis()->SetTitle("Entries/bin");

  hxtot = tfs->make<TH1F>("hxtot","xtot",70000,-200,500);
  hxtot->GetXaxis()->SetTitle("Reconstructed X (cm)");
  hxtot->GetYaxis()->SetTitle("Entries/bin");

  hytot = tfs->make<TH1F>("hytot","ytot",60000,-300,300);
  hytot->GetXaxis()->SetTitle("Reconstructed Y (cm)");
  hytot->GetYaxis()->SetTitle("Entries/bin");

  hztot = tfs->make<TH1F>("hztot","ztot",130000,-100,1200);
  hztot->GetXaxis()->SetTitle("Reconstructed Z (cm)");
  hztot->GetYaxis()->SetTitle("Entries/bin");

  hPEShit = tfs->make<TH1F>("hPEShit","PEShit",500,0,500);
  hPEShit->GetXaxis()->SetTitle(" peshit");
  hPEShit->GetYaxis()->SetTitle("Entries/bin");
  // hit stuff ends here ////////////////////////////////////////////////////////////////////////
}

void crt::CRTAnalyser::initialize_tracks()
{
  // Implementation of required member function here.
  std::cout << "Initialize variables and histograms for tracks" << std::endl;
  //tree stuff for tracks: //////////////////////////////////////////////////////////////////////////////////
  my_tracks_ = tfs->make<TTree>("my_tracks","CRT Tree");
  my_tracks_->Branch("x1", &x1, "x1 (cm)/D");
  my_tracks_->Branch("y1", &y1, "y1 (cm)/D");
  my_tracks_->Branch("z1", &z1, "z1 (cm)/D");
  my_tracks_->Branch("x2", &x2, "x2 (cm)/D");
  my_tracks_->Branch("y2", &y2, "y2 (cm)/D");
  my_tracks_->Branch("z2", &z2, "z2 (cm)/D");
  my_tracks_->Branch("x1_err", &x1_err, "x1_err (cm)/D");
  my_tracks_->Branch("y1_err", &y1_err, "y1_err (cm)/D");
  my_tracks_->Branch("z1_err", &z1_err, "z1_err (cm)/D");
  my_tracks_->Branch("x2_err", &x2_err, "x2_err (cm)/D");
  my_tracks_->Branch("y2_err", &y2_err, "y2_err (cm)/D");
  my_tracks_->Branch("z2_err", &z2_err, "z2_err (cm)/D");
  my_tracks_->Branch("plane1", &plane1, "plane1/I");
  my_tracks_->Branch("plane2", &plane2, "plane2/I");
  my_tracks_->Branch("track_time_s", &track_time_s, "time (s)/D");
  my_tracks_->Branch("track_time_ns", &track_time_ns, "time (ns)/D");
  my_tracks_->Branch("track_length", &length, "Track lenght (cm)/D");
  my_tracks_->Branch("track_timdiff", &time_diff, "Time_diff (ns)/D");
  my_tracks_->Branch("track_theta", &theta, "Theta_xy (ยบ)/D");
  my_tracks_->Branch("track_phi", &phi, "Phi_xy (ยบ)/D");
  
  my_tracks_->Branch("track_time_1ns", &track_time_1ns, "time1 (ns)/D");
  my_tracks_->Branch("track_time_1ns_err", &track_time_1ns_err, "time1 error (ns)/D");
  my_tracks_->Branch("track_time_2ns", &track_time_2ns, "time2 (ns)/D");
  my_tracks_->Branch("track_time_2ns_err", &track_time_2ns_err, "time2 error (ns)/D");

  hplavspla = tfs->make<TH2F>("hplavspla","PlanevsPlane",4,0,4,4,0,4);
  hplavspla->GetXaxis()->SetTitle("Plane (0=Bottom, 1=FT, 2=Pipe, 3=Top)");
  hplavspla->GetYaxis()->SetTitle("Plane (0=Bottom, 1=FT, 2=Pipe, 3=Top)");
  hplavspla->GetZaxis()->SetTitle("Entries/bin");
  hplavspla->SetOption("COLZ");

  hTvsH = tfs->make<TH2F>("hTvsH","Track_vs_Hits",500,0,500,500,0,500);
  hTvsH->GetXaxis()->SetTitle("Number of CRTHits per event");
  hTvsH->GetYaxis()->SetTitle("Number of CRTTracks per event");
  hTvsH->GetZaxis()->SetTitle("Entries/bin");
  hTvsH->SetOption("COLZ");

  hTlength = tfs->make<TH1F>("hTlength","Track_Length",1500,0,1500);
  hTlength->GetXaxis()->SetTitle("Track_Length (cm)");
  hTlength->GetYaxis()->SetTitle("Entries/bin");

  hTtime = tfs->make<TH1F>("hTtime","Track_time",120,-10,110);
  hTtime->GetXaxis()->SetTitle("Track_time (ns)");
  hTtime->GetYaxis()->SetTitle("Entries/bin");

  hTlengthvsTime = tfs->make<TH2F>("hTlengthvsTime","Track_LengthvsTime",1500,0,1500,200,-100,100);
  hTlengthvsTime->GetXaxis()->SetTitle("Track_Length (cm)");
  hTlengthvsTime->GetYaxis()->SetTitle("Track_time (ns)");
  hTlengthvsTime->GetZaxis()->SetTitle("Entries/bin");
  hTlengthvsTime->SetOption("COLZ");

  hTlengthvsTimeAbs = tfs->make<TH2F>("hTlengthvsTimeAbs","Track_LengthvsTimeAbs",1500,0,1500,110,-10,100);
  hTlengthvsTimeAbs->GetXaxis()->SetTitle("Track_Length (cm)");
  hTlengthvsTimeAbs->GetYaxis()->SetTitle("Track_time (ns)");
  hTlengthvsTimeAbs->GetZaxis()->SetTitle("Entries/bin");
  hTlengthvsTimeAbs->SetOption("COLZ");

  hTlengthvsTimeAbs_prof = tfs->make<TProfile>("hTlengthvsTimeAbs_prof","Track_LengthvsTimeAbs_prof",1500,0,1500,"s");
  hTlengthvsTimeAbs_prof->GetXaxis()->SetTitle("Track_Length (cm)");
  hTlengthvsTimeAbs_prof->GetYaxis()->SetTitle("Track_time (ns)");

  htheta = tfs->make<TH1F>("htheta","Track_theta",900,0,180);
  htheta->GetXaxis()->SetTitle("Theta_xy (ยบ)");
  htheta->GetYaxis()->SetTitle("Entries/bin");
 
  hphi = tfs->make<TH1F>("hphi","Track_phi",900,0,180);
  hphi->GetXaxis()->SetTitle("Phi_zy (ยบ)");
  hphi->GetYaxis()->SetTitle("Entries/bin");

  hts0_ns = tfs->make<TH1F>("hts0_ns","Track_time_ns",100000,0,1e9);
  hts0_ns->GetXaxis()->SetTitle("Track time (ns)");
  hts0_ns->GetYaxis()->SetTitle("Entries/bin");
  
  double inch =2.54; //inch in cm                                                                                                                          
  TrackDistBot = tfs->make<TH2F>("hTBottom","TBottom",125,-700+205*inch,-700+205*inch+125*10.89,60,-300+50.4*inch,-300+50.4*inch+60*10.89);
  TrackDistBot->GetXaxis()->SetTitle("Lenght along the beam (cm)");
  TrackDistBot->GetYaxis()->SetTitle("Lenght along the drift (cm)");
  TrackDistBot->GetZaxis()->SetTitle("Entries/bin");
  TrackDistBot->SetOption("COLZ");

  TrackDistFT = tfs->make<TH2F>("hTFeedthroughSide","TFeedthrough Side",125,-704+205*inch,-704+205*inch+125*10.89,60,-308-19.1*inch,-308-19.1*inch+60*10.89);
  TrackDistFT->GetXaxis()->SetTitle("Lenght along the beam (cm)");
  TrackDistFT->GetYaxis()->SetTitle("Height (cm)");
  TrackDistFT->GetZaxis()->SetTitle("Entries/bin");
  TrackDistFT->SetOption("COLZ");

  TrackDistPipe = tfs->make<TH2F>("hTPipeSide","TPipe Side",125,-704+205*inch,-704+205*inch+125*10.89,60,-294-19.1*inch,-294-19.1*inch+60*10.89);
  TrackDistPipe->GetXaxis()->SetTitle("Lenght along the beam (cm)");
  TrackDistPipe->GetYaxis()->SetTitle("Height (cm)");
  TrackDistPipe->GetZaxis()->SetTitle("Entries/bin");
  TrackDistPipe->SetOption("COLZ");

  TrackDistTop = tfs->make<TH2F>("hTTop","TTop",125,-701+205*inch,-701+205*inch+125*11.38,80,2-170-300+50.4*inch,2-170-300+50.4*inch+80*11.38);
  TrackDistTop->GetXaxis()->SetTitle("Lenght along the beam (cm)");
  TrackDistTop->GetYaxis()->SetTitle("Lenght along the drift (cm)");
  TrackDistTop->GetZaxis()->SetTitle("Entries/bin");
  TrackDistTop->SetOption("COLZ");

}

void crt::CRTAnalyser::beginJob()
{
  // Implementation of optional member function here.
  initialize_hits();
  initialize_tracks();
  
}
void crt::CRTAnalyser::endJob()
{
  // Implementation of optional member function here.
}
DEFINE_ART_MODULE(crt::CRTAnalyser)
